{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Daiquiri Daiquiri is a framework for the publication of scientific databases. Home page https://django-daiquiri.github.io GitHub organization https://github.com/django-daiquiri PyPI releases https://pypi.org/project/django-daiquiri Introduction Today, the publication of research data plays an important role in astronomy and astrophysics. On the one hand, dedicated surveys like SDSS and RAVE, data intensive instruments like LOFAR, or massive simulations like Millennium and MultiDark are initially planned to release their data for the community. On the other hand, more traditionally oriented research projects strive to publish their data as a key requirement demanded by the funding agencies. The common approach is to publish this data via dedicated web sites. This includes rather simple HTML forms as well as complex query systems such as SDSS-CAS. Most of these web sites are tailor made for the particular case and are therefore not easily transferable to future projects. At Leibniz-Institute for Astrophysics Potsdam (AIP) , we gained experience with both the maintenance and the development of such applications. It became, however, apparent that already the current plethora of applications constitutes a major challenge for maintenance expenses and scalability. In order to address these issues, we developed the Daiquiri framework , which is particularly designed to allow for different highly customizable web applications based on a common easily maintainable code base. Features Daiquiri enables collaboration and institutions to create customized websites, comprising of the following features: An interactive Query interface enabling users to perform SQL/ADQL queries against catalog databases. The queries are analyzed using the queryparser and permissions are checked depending on user accounts and groups. Asynchronous database queries, which can take minutes or even hours. Download of the query results in different formats and visualization of the data. A programmatic interface to the database implementing the IVOA TAP protocol. A cone search API based on the IVOA Simple Cone Search recommendation. An integration into to IVOA registry of registry to make the VO endpoints available in applications like, e.g. topcat . A metadata management backend containing information about the database schemas and tables including DOI and UCD. The download of files connected to the database tables, including access restrictions. An OAI-PMH2 endpoint to make the metadata stored in the system available to harvesters. A cut-out API for multi-dimensional data (e.g. data cubes). A sophisticated user management system with customizable registration and confirmation workflows. A contact form connected to the management backend. A meeting module to organize workshops and smaller conferences. An integrated WordPress content management system for documentation and/or the presentation of the project. Requirements Daiquiri is based on Django and is written in Python. The following requirements are mandatory: Python >=3.5 PostgreSQL >=10 , MariaDB >=10.1 or MySQL >=5.6 RabbitMQ >=3.5 (for asyncronous tasks like the query queue) For demonstration, development or testing purposes, Daiquiri can be installed on Linux, macOS, or even Windows. If you, however, intent to set up a production enviroment, serving Daiquiri over a Network or the Internet, we strongly suggest that you use a recent Linux distribution, namely: Debian 10 Ubuntu 18.04 CentOS 7 CentOS 8 (there are still some packages missing as of October 2019) Usage Daiquiri is currently used on several sites hosted and maintained by the Leibniz-Institute for Astrophysics Potsdam (AIP) : Gaia@AIP Services APPLAUSE archives MUSE-Wide survey GREGOR project and archive CLUES \u2013 Constrained Local UniversE Simulations project CosmoSim database (legacy version) RAVE Survey (legacy version) License Daiquiri is Licensed unter the Apache License 2.0 . The full license text is part of the source code repository at github.com/django-daiquiri/daiquiri .","title":"Home"},{"location":"#daiquiri","text":"Daiquiri is a framework for the publication of scientific databases. Home page https://django-daiquiri.github.io GitHub organization https://github.com/django-daiquiri PyPI releases https://pypi.org/project/django-daiquiri","title":"Daiquiri"},{"location":"#introduction","text":"Today, the publication of research data plays an important role in astronomy and astrophysics. On the one hand, dedicated surveys like SDSS and RAVE, data intensive instruments like LOFAR, or massive simulations like Millennium and MultiDark are initially planned to release their data for the community. On the other hand, more traditionally oriented research projects strive to publish their data as a key requirement demanded by the funding agencies. The common approach is to publish this data via dedicated web sites. This includes rather simple HTML forms as well as complex query systems such as SDSS-CAS. Most of these web sites are tailor made for the particular case and are therefore not easily transferable to future projects. At Leibniz-Institute for Astrophysics Potsdam (AIP) , we gained experience with both the maintenance and the development of such applications. It became, however, apparent that already the current plethora of applications constitutes a major challenge for maintenance expenses and scalability. In order to address these issues, we developed the Daiquiri framework , which is particularly designed to allow for different highly customizable web applications based on a common easily maintainable code base.","title":"Introduction"},{"location":"#features","text":"Daiquiri enables collaboration and institutions to create customized websites, comprising of the following features: An interactive Query interface enabling users to perform SQL/ADQL queries against catalog databases. The queries are analyzed using the queryparser and permissions are checked depending on user accounts and groups. Asynchronous database queries, which can take minutes or even hours. Download of the query results in different formats and visualization of the data. A programmatic interface to the database implementing the IVOA TAP protocol. A cone search API based on the IVOA Simple Cone Search recommendation. An integration into to IVOA registry of registry to make the VO endpoints available in applications like, e.g. topcat . A metadata management backend containing information about the database schemas and tables including DOI and UCD. The download of files connected to the database tables, including access restrictions. An OAI-PMH2 endpoint to make the metadata stored in the system available to harvesters. A cut-out API for multi-dimensional data (e.g. data cubes). A sophisticated user management system with customizable registration and confirmation workflows. A contact form connected to the management backend. A meeting module to organize workshops and smaller conferences. An integrated WordPress content management system for documentation and/or the presentation of the project.","title":"Features"},{"location":"#requirements","text":"Daiquiri is based on Django and is written in Python. The following requirements are mandatory: Python >=3.5 PostgreSQL >=10 , MariaDB >=10.1 or MySQL >=5.6 RabbitMQ >=3.5 (for asyncronous tasks like the query queue) For demonstration, development or testing purposes, Daiquiri can be installed on Linux, macOS, or even Windows. If you, however, intent to set up a production enviroment, serving Daiquiri over a Network or the Internet, we strongly suggest that you use a recent Linux distribution, namely: Debian 10 Ubuntu 18.04 CentOS 7 CentOS 8 (there are still some packages missing as of October 2019)","title":"Requirements"},{"location":"#usage","text":"Daiquiri is currently used on several sites hosted and maintained by the Leibniz-Institute for Astrophysics Potsdam (AIP) : Gaia@AIP Services APPLAUSE archives MUSE-Wide survey GREGOR project and archive CLUES \u2013 Constrained Local UniversE Simulations project CosmoSim database (legacy version) RAVE Survey (legacy version)","title":"Usage"},{"location":"#license","text":"Daiquiri is Licensed unter the Apache License 2.0 . The full license text is part of the source code repository at github.com/django-daiquiri/daiquiri .","title":"License"},{"location":"appendix/","text":"Appendix Apache2 and mod_wsgi This is an alternative deployment without the need of systemd scripts for the web application. Any asyncronous workers, however, would still need these systemd scripts. Install the Apache server and mod_wsgi on Debian or Ubuntu using: sudo apt install apache2 libapache2-mod-wsgi-py3 On CentOS 7 you need to enable the [IUS repository] first. Then install using: sudo yum install httpd python35u-mod_wsgi Then, edit the virtual host configuration: # in /etc/httpd/sites-available/default on Debian/Ubuntu # in /etc/httpd/conf.d/vhost.conf on RHEL/CentOS <VirtualHost *:80> ... WSGIDaemonProcess daiquiri user=daiquiri group=daiquiri \\ home=/srv/daiquiri/app python-home=/srv/daiquiri/app/env WSGIProcessGroup daiquiri WSGIScriptAlias / /srv/daiquiri/app/config/wsgi.py process-group=daiquiri WSGIPassAuthorization On Alias /static /srv/daiquiri/app/static_root/ <Directory /srv/daiquiri/app/static_root/> Require all granted </Directory> <Directory /srv/daiquiri/app/config/> <Files wsgi.py> Require all granted </Files> </Directory> </VirtualHost> Start the Apache server: # on Debian/Ubuntu sudo systemctl start apache2 sudo systemctl enable apache2 # on RHEL/CentOS sudo systemctl start httpd sudo systemctl enable httpd Your Daiquiri app should now be available on the configured virtual host, and the deployment can be continued as usual. WordPress integration WordPress can be used as CMS for the documentation and/or the presentation of the project. For this documentation, we assume WordPress will be installed /opt/wordpress . First, you need to install PHP: # Debian 10 sudo apt-get install php7.3 php7.3-mysql php-pear pear install HTTP_Request2 # Ubuntu 18.04 sudo apt-get install php7.2 php7.2-mysql php-pear pear install HTTP_Request2 The code needs to be downloaded from [WordPress.org] and extracted: # as root cd /opt wget https://wordpress.org/latest.tar.gz tar xzvf latest.tar.gz The the [Daiquiri theme] and the [Daiquiri plugin] need to be installed: # as root cd /opt/wordpress/wp-content/themes git clone https://github.com/django-daiquiri/wordpress-theme daiquiri cd /opt/wordpress/wp-content/plugins git clone https://github.com/django-daiquiri/wordpress-plugin daiquiri The WordPress directory need to be owned by the Apache2 user: chown -R www-data:www-data /opt/wordpress # Debian/Ubuntu chown -R apache:apache /opt/wordpress # CentOS Then, create the wp-config.php file cp /opt/wordpress/wp-config-sample.php /opt/wordpress/wp-config.php and edit the file for the database connection for WordPress (not the same as for Daiquiri, needs MySQL or MariaDB): define( 'DB_NAME', 'database_name_here' ); define( 'DB_USER', 'username_here' ); define( 'DB_PASSWORD', 'password_here' ); define( 'DB_HOST', 'localhost' ); In addition, update the salt values and add the following at the end of the file, but before That's all, stop editing! : define('DAIQUIRI_DEBUG', False); define('DAIQUIRI_URL', 'https://<the url your daiquiri app>'); define('COOKIEPATH','/'); define('SITECOOKIEPATH',COOKIEPATH); define('ADMIN_COOKIE_PATH',COOKIEPATH); define('PLUGINS_COOKIE_PATH',COOKIEPATH); The go to http:// /cms/ and follow the WordPress instalation. You can use a username which you already registered in Daiquiri. After the installation log in into the WordPress backend. Then: Activate the Daiquiri theme under Appearance -> Themes Activate the Daiquiri plugin under Appearance -> Plugins Logout of WordPress. Login to Daiquiri. You should now be logged in into WordPress as well. The syncronization of WordPress and Daiquiri users is done using wp-cli . See settings for more information about using WordPress with Daiquiri.","title":"Appendix"},{"location":"appendix/#appendix","text":"","title":"Appendix"},{"location":"appendix/#apache2-and-mod_wsgi","text":"This is an alternative deployment without the need of systemd scripts for the web application. Any asyncronous workers, however, would still need these systemd scripts. Install the Apache server and mod_wsgi on Debian or Ubuntu using: sudo apt install apache2 libapache2-mod-wsgi-py3 On CentOS 7 you need to enable the [IUS repository] first. Then install using: sudo yum install httpd python35u-mod_wsgi Then, edit the virtual host configuration: # in /etc/httpd/sites-available/default on Debian/Ubuntu # in /etc/httpd/conf.d/vhost.conf on RHEL/CentOS <VirtualHost *:80> ... WSGIDaemonProcess daiquiri user=daiquiri group=daiquiri \\ home=/srv/daiquiri/app python-home=/srv/daiquiri/app/env WSGIProcessGroup daiquiri WSGIScriptAlias / /srv/daiquiri/app/config/wsgi.py process-group=daiquiri WSGIPassAuthorization On Alias /static /srv/daiquiri/app/static_root/ <Directory /srv/daiquiri/app/static_root/> Require all granted </Directory> <Directory /srv/daiquiri/app/config/> <Files wsgi.py> Require all granted </Files> </Directory> </VirtualHost> Start the Apache server: # on Debian/Ubuntu sudo systemctl start apache2 sudo systemctl enable apache2 # on RHEL/CentOS sudo systemctl start httpd sudo systemctl enable httpd Your Daiquiri app should now be available on the configured virtual host, and the deployment can be continued as usual.","title":"Apache2 and mod_wsgi"},{"location":"appendix/#wordpress-integration","text":"WordPress can be used as CMS for the documentation and/or the presentation of the project. For this documentation, we assume WordPress will be installed /opt/wordpress . First, you need to install PHP: # Debian 10 sudo apt-get install php7.3 php7.3-mysql php-pear pear install HTTP_Request2 # Ubuntu 18.04 sudo apt-get install php7.2 php7.2-mysql php-pear pear install HTTP_Request2 The code needs to be downloaded from [WordPress.org] and extracted: # as root cd /opt wget https://wordpress.org/latest.tar.gz tar xzvf latest.tar.gz The the [Daiquiri theme] and the [Daiquiri plugin] need to be installed: # as root cd /opt/wordpress/wp-content/themes git clone https://github.com/django-daiquiri/wordpress-theme daiquiri cd /opt/wordpress/wp-content/plugins git clone https://github.com/django-daiquiri/wordpress-plugin daiquiri The WordPress directory need to be owned by the Apache2 user: chown -R www-data:www-data /opt/wordpress # Debian/Ubuntu chown -R apache:apache /opt/wordpress # CentOS Then, create the wp-config.php file cp /opt/wordpress/wp-config-sample.php /opt/wordpress/wp-config.php and edit the file for the database connection for WordPress (not the same as for Daiquiri, needs MySQL or MariaDB): define( 'DB_NAME', 'database_name_here' ); define( 'DB_USER', 'username_here' ); define( 'DB_PASSWORD', 'password_here' ); define( 'DB_HOST', 'localhost' ); In addition, update the salt values and add the following at the end of the file, but before That's all, stop editing! : define('DAIQUIRI_DEBUG', False); define('DAIQUIRI_URL', 'https://<the url your daiquiri app>'); define('COOKIEPATH','/'); define('SITECOOKIEPATH',COOKIEPATH); define('ADMIN_COOKIE_PATH',COOKIEPATH); define('PLUGINS_COOKIE_PATH',COOKIEPATH); The go to http:// /cms/ and follow the WordPress instalation. You can use a username which you already registered in Daiquiri. After the installation log in into the WordPress backend. Then: Activate the Daiquiri theme under Appearance -> Themes Activate the Daiquiri plugin under Appearance -> Plugins Logout of WordPress. Login to Daiquiri. You should now be logged in into WordPress as well. The syncronization of WordPress and Daiquiri users is done using wp-cli . See settings for more information about using WordPress with Daiquiri.","title":"WordPress integration"},{"location":"deployment/","text":"Deployment Configuration In production, you should create a dedicated user for your Daiquiri application. All steps for the installation, which do not need root access, should be done using this user. As before, we assume this user is called daiquiri and it\u2019s home is /srv/daiquiri and therefore your app is located in /srv/daiquiri/app . In addition, a few more settings need to be configured in your .env file. The most important change is to set DEBUG=False . DEBUG=False ALLOWED_HOSTS=<hostname> # ADMINS will get E-Mails in case of an error ADMINS=Anna Admin <admin@example.com>, Manni Manager <manager@example.com> LOG_DIR=/var/log/django/daiquiri Web server Daiquiri can be run in different configurations, both with Apache2 and NGINX as web server. Daiquiri itself is using the wsgi protocol for the communication between the HTTP and the Python layer. The recommended way of deploying Daiquiri is using Apache2 as a reverse proxy and Gunicorn as wsgi server. For this setup, you need to add: PROXY=True to your .env file. First install Gunicorn inside your virtual environment: pip install gunicorn Then, test gunicorn using: gunicorn --bind 0.0.0.0:8000 config.wsgi:application This should serve the application like runserver , but without the static assets, like CSS files and images. After the test kill the gunicorn process again. Systemd will launch the gunicorn process on startup and keep running. In order to start/restart/stop the web application as well as the asyncronous workers with one command, first create a pseudo-service for your Daiquiri application by creating the file /etc/systemd/system/daiquiri.service (you will need root/sudo permissions for that): [Unit] Description=pseudo-service for all Daiquiri services [Service] Type=oneshot ExecStart=/bin/true RemainAfterExit=yes [Install] WantedBy=network.target Then create the systemd service file for the actual web application in /etc/systemd/system/daiquiri-app.service : [Unit] Description=Daiquiri gunicorn daemon PartOf=daiquiri.service After=daiquiri.service [Service] User=daiquiri Group=daiquiri WorkingDirectory=/srv/daiquiri/app Environment=GUNICORN_BIN=/srv/daiquiri/app/env/bin/gunicorn Environment=GUNICORN_WORKER=5 Environment=GUNICORN_PORT=9000 Environment=GUNICORN_TIMEOUT=120 Environment=GUNICORN_PID_FILE=/var/run/gunicorn/daiquiri/pid Environment=GUNICORN_ACCESS_LOG_FILE=/var/log/gunicorn/daiquiri/access.log Environment=GUNICORN_ERROR_LOG_FILE=/var/log/gunicorn/daiquiri/error.log ExecStart=/bin/sh -c '${GUNICORN_BIN} \\ --workers ${GUNICORN_WORKER} \\ --pid ${GUNICORN_PID_FILE} \\ --bind localhost:${GUNICORN_PORT} \\ --timeout ${GUNICORN_TIMEOUT} \\ --access-logfile ${GUNICORN_ACCESS_LOG_FILE} \\ --error-logfile ${GUNICORN_ERROR_LOG_FILE} \\ config.wsgi:application' ExecReload=/bin/sh -c '/usr/bin/pkill -HUP -F ${GUNICORN_PID_FILE}' ExecStop=/bin/sh -c '/usr/bin/pkill -TERM -F ${GUNICORN_PID_FILE}' [Install] WantedBy=daiquiri.target The setup needs to have several directories for logfiles set up with the correct permissions. This can be done using tmpfiles.d . First, create a file /etc/tmpfiles.d/daiquiri.conf : d /run/celery/daiquiri 750 daiquiri daiquiri d /run/gunicorn/daiquiri 750 daiquiri daiquiri d /var/log/django/daiquiri 750 daiquiri daiquiri d /var/log/celery/daiquiri 750 daiquiri daiquiri d /var/log/gunicorn/daiquiri 755 daiquiri daiquiri Then run: systemd-tmpfiles --create The daiquiri systemd service needs to be started and enabled like any other service: sudo systemctl daemon-reload sudo systemctl start daiquiri sudo systemctl enable daiquiri Next, install the web server. On Debian/Ubuntu use: sudo apt install apache2 libapache2-mod-xsendfile sudo a2enmod proxy sudo a2enmod remoteip sudo a2enmod headers and on CentOS 7/8 use sudo yum install httpd mod_xsendfile Then, edit the virtual host configuration to create a reverse proxy to the Gunicorn server: # in /etc/apache2/sites-available/000-default.conf on Debian/Ubuntu # in /etc/httpd/conf.d/vhost.conf on RHEL/CentOS <VirtualHost *:80> ... DocumentRoot \"/var/www/html\" XSendFile on XSendFilePath <FILES_BASE_PATH from the Daiquiri settings> XSendFilePath <QUERY_DOWNLOAD_PATH from the Daiquiri settings> RequestHeader set X-Forwarded-Proto 'https' env=HTTPS ProxyPass /static ! ProxyPass /cms ! ProxyPass / http://localhost:9000/ ProxyPassReverse /dev http://localhost:9000/ Alias /static/ /srv/daiquiri/app/static_root/ <Directory /srv/daiquiri/app/static_root/> Require all granted </Directory> # if you intent to use the WordPress integration Alias /cms/ /opt/wordpress/ <Directory /opt/wordpress/> AllowOverride all Require all granted </Directory> <Location /cms/wp-json/> Deny from all </Location> </VirtualHost> On CentOS selinux needs to be set to persive (or configured properly): setenforce permissive Start the Apache server: sudo systemctl restart apache2 # on Debian/Ubuntu sudo systemctl restart httpd # on RHEL/CentOS Your Daiquiri app should now be available on the configured virtual host, but again, without the static assets, like CSS files and images. Static assets As you can see from the virtual host configurations, the static assets such as CSS and JavaScript files are served independently from the WSGI-python script. In order to do so, they need to be gathered in the static_root directory. This can be achieved by running: python manage.py collectstatic in your virtual environment. The Apache user needs to have read permissions to /srv/daiquiri/app/static_root/ . In order to apply changes to the code, the daiquiri-app job needs to be reloaded. Asyncronous workers In production, and especially if you intent to run several Daiquiri applications on the same RabbitMQ instance, it is recomended to use virtual hosts and users with RabbitMQ. In order to create a virtual host and a user use the following commands on your RabbitMQ host: # first enable the managemetn interface and crate an admin user rabbitmq-plugins enable rabbitmq_management rabbitmqctl add_user admin <a secret password> rabbitmqctl set_user_tags admin administrator # then create a vhost and a user for your daiquiri app rabbitmqctl add_vhost <vhost> rabbitmqctl add_user <user> <a secret password> rabbitmqctl set_permissions -p <user> <user> \".*\" \".*\" \".*\" rabbitmqctl set_permissions -p <user> admin \".*\" \".*\" \".*\" Then add CELERY_BROKER_URL to the .env file of your Daiquiri application: CELERY_BROKER_URL=amqp://<user>:<password>@<host>:<port>/<vhost> As with the Gunicorn process, the asyncronous workers are also using systemd to launch and keep running. Create the following service files for the three workers: # in /etc/systemd/system/daiquiri-default-worker.service [Unit] Description=celery worker for the default queue PartOf=daiquiri.service After=daiquiri.service [Service] Type=forking User=daiquiri Group=daiquiri WorkingDirectory=/srv/daiquiri/app Environment=CELERY_BIN=/srv/daiquiri/app/env/bin/celery Environment=CELERYD_NODE=daiquiri_default Environment=CELERYD_QUEUE=default Environment=CELERYD_CONCURRENCY=1 Environment=CELERYD_PID_FILE=/var/run/celery/daiquiri/default.pid Environment=CELERYD_LOG_FILE=/var/log/celery/daiquiri/default.log Environment=CELERYD_LOG_LEVEL=INFO ExecStart=/bin/sh -c '${CELERY_BIN} multi start ${CELERYD_NODE} \\ -A config \\ -Q ${CELERYD_QUEUE} \\ -c ${CELERYD_CONCURRENCY} \\ --pidfile=${CELERYD_PID_FILE} \\ --logfile=${CELERYD_LOG_FILE} \\ --loglevel=${CELERYD_LOG_LEVEL}' ExecStop=/bin/sh -c '${CELERY_BIN} multi stopwait ${CELERYD_NODE} \\ --pidfile=${CELERYD_PID_FILE}' ExecReload=/bin/sh -c '${CELERY_BIN} multi restart ${CELERYD_NODE} \\ -A config \\ -Q ${CELERYD_QUEUE} \\ -c ${ELERYD_CONCURRENCY} \\ --pidfile=${CELERYD_PID_FILE} \\ --logfile=${CELERYD_LOG_FILE} \\ --loglevel=${CELERYD_LOG_LEVEL}' [Install] WantedBy=daiquiri.service # in /etc/systemd/system/daiquiri-query-worker.service [Unit] Description=celery worker for the query queue PartOf=daiquiri.service After=daiquiri.service [Service] Type=forking User=daiquiri Group=daiquiri WorkingDirectory=/srv/daiquiri/app Environment=CELERY_BIN=/srv/daiquiri/app/env/bin/celery Environment=CELERYD_NODE=daiquiri_query Environment=CELERYD_QUEUE=query Environment=CELERYD_CONCURRENCY=1 Environment=CELERYD_PID_FILE=/var/run/celery/daiquiri/query.pid Environment=CELERYD_LOG_FILE=/var/log/celery/daiquiri/query.log Environment=CELERYD_LOG_LEVEL=INFO ExecStart=/bin/sh -c '${CELERY_BIN} multi start ${CELERYD_NODE} \\ -A config \\ -Q ${CELERYD_QUEUE} \\ -c ${CELERYD_CONCURRENCY} \\ --pidfile=${CELERYD_PID_FILE} \\ --logfile=${CELERYD_LOG_FILE} \\ --loglevel=${CELERYD_LOG_LEVEL}' ExecStop=/bin/sh -c '${CELERY_BIN} multi stopwait ${CELERYD_NODE} \\ --pidfile=${CELERYD_PID_FILE}' ExecReload=/bin/sh -c '${CELERY_BIN} multi restart ${CELERYD_NODE} \\ -A config \\ -Q ${CELERYD_QUEUE} \\ -c ${ELERYD_CONCURRENCY} \\ --pidfile=${CELERYD_PID_FILE} \\ --logfile=${CELERYD_LOG_FILE} \\ --loglevel=${CELERYD_LOG_LEVEL}' [Install] WantedBy=daiquiri.service # in /etc/systemd/system/daiquiri-download-worker.service [Unit] Description=celery worker for the download queue PartOf=daiquiri.service After=daiquiri.service [Service] Type=forking User=daiquiri Group=daiquiri WorkingDirectory=/srv/daiquiri/app Environment=CELERY_BIN=/srv/daiquiri/app/env/bin/celery Environment=CELERYD_NODE=daiquiri_download Environment=CELERYD_QUEUE=download Environment=CELERYD_CONCURRENCY=1 Environment=CELERYD_PID_FILE=/var/run/celery/daiquiri/download.pid Environment=CELERYD_LOG_FILE=/var/log/celery/daiquiri/download.log Environment=CELERYD_LOG_LEVEL=INFO ExecStart=/bin/sh -c '${CELERY_BIN} multi start ${CELERYD_NODE} \\ -A config \\ -Q ${CELERYD_QUEUE} \\ -c ${CELERYD_CONCURRENCY} \\ --pidfile=${CELERYD_PID_FILE} \\ --logfile=${CELERYD_LOG_FILE} \\ --loglevel=${CELERYD_LOG_LEVEL}' ExecStop=/bin/sh -c '${CELERY_BIN} multi stopwait ${CELERYD_NODE} \\ --pidfile=${CELERYD_PID_FILE}' ExecReload=/bin/sh -c '${CELERY_BIN} multi restart ${CELERYD_NODE} \\ -A config \\ -Q ${CELERYD_QUEUE} \\ -c ${CELERYD_CONCURRENCY} \\ --pidfile=${CELERYD_PID_FILE} \\ --logfile=${CELERYD_LOG_FILE} \\ --loglevel=${CELERYD_LOG_LEVEL}' [Install] WantedBy=daiquiri.service Then, the worker can be started and enabled as before: sudo systemctl daemon-reload sudo systemctl start daiquiri-default-worker sudo systemctl start daiquiri-query-worker sudo systemctl start daiquiri-download-worker sudo systemctl enable daiquiri-default-worker sudo systemctl enable daiquiri-query-worker sudo systemctl enable daiquiri-download-worker Caching To use memcached as cache, first install it from the distribution: apt install memcached # Debian/Ubuntu yum install memcached # CentOS On CentOS memcached needs to be restricted to listen only to localhost in /etc/sysconfig/memcached : PORT=\"11211\" USER=\"memcached\" MAXCONN=\"1024\" CACHESIZE=\"64\" OPTIONS=\"-l 127.0.0.1,::1\" Then memcached can be enabled and started: systemctl start memcached systemctl enable memcached","title":"Deployment"},{"location":"deployment/#deployment","text":"","title":"Deployment"},{"location":"deployment/#configuration","text":"In production, you should create a dedicated user for your Daiquiri application. All steps for the installation, which do not need root access, should be done using this user. As before, we assume this user is called daiquiri and it\u2019s home is /srv/daiquiri and therefore your app is located in /srv/daiquiri/app . In addition, a few more settings need to be configured in your .env file. The most important change is to set DEBUG=False . DEBUG=False ALLOWED_HOSTS=<hostname> # ADMINS will get E-Mails in case of an error ADMINS=Anna Admin <admin@example.com>, Manni Manager <manager@example.com> LOG_DIR=/var/log/django/daiquiri","title":"Configuration"},{"location":"deployment/#web-server","text":"Daiquiri can be run in different configurations, both with Apache2 and NGINX as web server. Daiquiri itself is using the wsgi protocol for the communication between the HTTP and the Python layer. The recommended way of deploying Daiquiri is using Apache2 as a reverse proxy and Gunicorn as wsgi server. For this setup, you need to add: PROXY=True to your .env file. First install Gunicorn inside your virtual environment: pip install gunicorn Then, test gunicorn using: gunicorn --bind 0.0.0.0:8000 config.wsgi:application This should serve the application like runserver , but without the static assets, like CSS files and images. After the test kill the gunicorn process again. Systemd will launch the gunicorn process on startup and keep running. In order to start/restart/stop the web application as well as the asyncronous workers with one command, first create a pseudo-service for your Daiquiri application by creating the file /etc/systemd/system/daiquiri.service (you will need root/sudo permissions for that): [Unit] Description=pseudo-service for all Daiquiri services [Service] Type=oneshot ExecStart=/bin/true RemainAfterExit=yes [Install] WantedBy=network.target Then create the systemd service file for the actual web application in /etc/systemd/system/daiquiri-app.service : [Unit] Description=Daiquiri gunicorn daemon PartOf=daiquiri.service After=daiquiri.service [Service] User=daiquiri Group=daiquiri WorkingDirectory=/srv/daiquiri/app Environment=GUNICORN_BIN=/srv/daiquiri/app/env/bin/gunicorn Environment=GUNICORN_WORKER=5 Environment=GUNICORN_PORT=9000 Environment=GUNICORN_TIMEOUT=120 Environment=GUNICORN_PID_FILE=/var/run/gunicorn/daiquiri/pid Environment=GUNICORN_ACCESS_LOG_FILE=/var/log/gunicorn/daiquiri/access.log Environment=GUNICORN_ERROR_LOG_FILE=/var/log/gunicorn/daiquiri/error.log ExecStart=/bin/sh -c '${GUNICORN_BIN} \\ --workers ${GUNICORN_WORKER} \\ --pid ${GUNICORN_PID_FILE} \\ --bind localhost:${GUNICORN_PORT} \\ --timeout ${GUNICORN_TIMEOUT} \\ --access-logfile ${GUNICORN_ACCESS_LOG_FILE} \\ --error-logfile ${GUNICORN_ERROR_LOG_FILE} \\ config.wsgi:application' ExecReload=/bin/sh -c '/usr/bin/pkill -HUP -F ${GUNICORN_PID_FILE}' ExecStop=/bin/sh -c '/usr/bin/pkill -TERM -F ${GUNICORN_PID_FILE}' [Install] WantedBy=daiquiri.target The setup needs to have several directories for logfiles set up with the correct permissions. This can be done using tmpfiles.d . First, create a file /etc/tmpfiles.d/daiquiri.conf : d /run/celery/daiquiri 750 daiquiri daiquiri d /run/gunicorn/daiquiri 750 daiquiri daiquiri d /var/log/django/daiquiri 750 daiquiri daiquiri d /var/log/celery/daiquiri 750 daiquiri daiquiri d /var/log/gunicorn/daiquiri 755 daiquiri daiquiri Then run: systemd-tmpfiles --create The daiquiri systemd service needs to be started and enabled like any other service: sudo systemctl daemon-reload sudo systemctl start daiquiri sudo systemctl enable daiquiri Next, install the web server. On Debian/Ubuntu use: sudo apt install apache2 libapache2-mod-xsendfile sudo a2enmod proxy sudo a2enmod remoteip sudo a2enmod headers and on CentOS 7/8 use sudo yum install httpd mod_xsendfile Then, edit the virtual host configuration to create a reverse proxy to the Gunicorn server: # in /etc/apache2/sites-available/000-default.conf on Debian/Ubuntu # in /etc/httpd/conf.d/vhost.conf on RHEL/CentOS <VirtualHost *:80> ... DocumentRoot \"/var/www/html\" XSendFile on XSendFilePath <FILES_BASE_PATH from the Daiquiri settings> XSendFilePath <QUERY_DOWNLOAD_PATH from the Daiquiri settings> RequestHeader set X-Forwarded-Proto 'https' env=HTTPS ProxyPass /static ! ProxyPass /cms ! ProxyPass / http://localhost:9000/ ProxyPassReverse /dev http://localhost:9000/ Alias /static/ /srv/daiquiri/app/static_root/ <Directory /srv/daiquiri/app/static_root/> Require all granted </Directory> # if you intent to use the WordPress integration Alias /cms/ /opt/wordpress/ <Directory /opt/wordpress/> AllowOverride all Require all granted </Directory> <Location /cms/wp-json/> Deny from all </Location> </VirtualHost> On CentOS selinux needs to be set to persive (or configured properly): setenforce permissive Start the Apache server: sudo systemctl restart apache2 # on Debian/Ubuntu sudo systemctl restart httpd # on RHEL/CentOS Your Daiquiri app should now be available on the configured virtual host, but again, without the static assets, like CSS files and images.","title":"Web server"},{"location":"deployment/#static-assets","text":"As you can see from the virtual host configurations, the static assets such as CSS and JavaScript files are served independently from the WSGI-python script. In order to do so, they need to be gathered in the static_root directory. This can be achieved by running: python manage.py collectstatic in your virtual environment. The Apache user needs to have read permissions to /srv/daiquiri/app/static_root/ . In order to apply changes to the code, the daiquiri-app job needs to be reloaded.","title":"Static assets"},{"location":"deployment/#asyncronous-workers","text":"In production, and especially if you intent to run several Daiquiri applications on the same RabbitMQ instance, it is recomended to use virtual hosts and users with RabbitMQ. In order to create a virtual host and a user use the following commands on your RabbitMQ host: # first enable the managemetn interface and crate an admin user rabbitmq-plugins enable rabbitmq_management rabbitmqctl add_user admin <a secret password> rabbitmqctl set_user_tags admin administrator # then create a vhost and a user for your daiquiri app rabbitmqctl add_vhost <vhost> rabbitmqctl add_user <user> <a secret password> rabbitmqctl set_permissions -p <user> <user> \".*\" \".*\" \".*\" rabbitmqctl set_permissions -p <user> admin \".*\" \".*\" \".*\" Then add CELERY_BROKER_URL to the .env file of your Daiquiri application: CELERY_BROKER_URL=amqp://<user>:<password>@<host>:<port>/<vhost> As with the Gunicorn process, the asyncronous workers are also using systemd to launch and keep running. Create the following service files for the three workers: # in /etc/systemd/system/daiquiri-default-worker.service [Unit] Description=celery worker for the default queue PartOf=daiquiri.service After=daiquiri.service [Service] Type=forking User=daiquiri Group=daiquiri WorkingDirectory=/srv/daiquiri/app Environment=CELERY_BIN=/srv/daiquiri/app/env/bin/celery Environment=CELERYD_NODE=daiquiri_default Environment=CELERYD_QUEUE=default Environment=CELERYD_CONCURRENCY=1 Environment=CELERYD_PID_FILE=/var/run/celery/daiquiri/default.pid Environment=CELERYD_LOG_FILE=/var/log/celery/daiquiri/default.log Environment=CELERYD_LOG_LEVEL=INFO ExecStart=/bin/sh -c '${CELERY_BIN} multi start ${CELERYD_NODE} \\ -A config \\ -Q ${CELERYD_QUEUE} \\ -c ${CELERYD_CONCURRENCY} \\ --pidfile=${CELERYD_PID_FILE} \\ --logfile=${CELERYD_LOG_FILE} \\ --loglevel=${CELERYD_LOG_LEVEL}' ExecStop=/bin/sh -c '${CELERY_BIN} multi stopwait ${CELERYD_NODE} \\ --pidfile=${CELERYD_PID_FILE}' ExecReload=/bin/sh -c '${CELERY_BIN} multi restart ${CELERYD_NODE} \\ -A config \\ -Q ${CELERYD_QUEUE} \\ -c ${ELERYD_CONCURRENCY} \\ --pidfile=${CELERYD_PID_FILE} \\ --logfile=${CELERYD_LOG_FILE} \\ --loglevel=${CELERYD_LOG_LEVEL}' [Install] WantedBy=daiquiri.service # in /etc/systemd/system/daiquiri-query-worker.service [Unit] Description=celery worker for the query queue PartOf=daiquiri.service After=daiquiri.service [Service] Type=forking User=daiquiri Group=daiquiri WorkingDirectory=/srv/daiquiri/app Environment=CELERY_BIN=/srv/daiquiri/app/env/bin/celery Environment=CELERYD_NODE=daiquiri_query Environment=CELERYD_QUEUE=query Environment=CELERYD_CONCURRENCY=1 Environment=CELERYD_PID_FILE=/var/run/celery/daiquiri/query.pid Environment=CELERYD_LOG_FILE=/var/log/celery/daiquiri/query.log Environment=CELERYD_LOG_LEVEL=INFO ExecStart=/bin/sh -c '${CELERY_BIN} multi start ${CELERYD_NODE} \\ -A config \\ -Q ${CELERYD_QUEUE} \\ -c ${CELERYD_CONCURRENCY} \\ --pidfile=${CELERYD_PID_FILE} \\ --logfile=${CELERYD_LOG_FILE} \\ --loglevel=${CELERYD_LOG_LEVEL}' ExecStop=/bin/sh -c '${CELERY_BIN} multi stopwait ${CELERYD_NODE} \\ --pidfile=${CELERYD_PID_FILE}' ExecReload=/bin/sh -c '${CELERY_BIN} multi restart ${CELERYD_NODE} \\ -A config \\ -Q ${CELERYD_QUEUE} \\ -c ${ELERYD_CONCURRENCY} \\ --pidfile=${CELERYD_PID_FILE} \\ --logfile=${CELERYD_LOG_FILE} \\ --loglevel=${CELERYD_LOG_LEVEL}' [Install] WantedBy=daiquiri.service # in /etc/systemd/system/daiquiri-download-worker.service [Unit] Description=celery worker for the download queue PartOf=daiquiri.service After=daiquiri.service [Service] Type=forking User=daiquiri Group=daiquiri WorkingDirectory=/srv/daiquiri/app Environment=CELERY_BIN=/srv/daiquiri/app/env/bin/celery Environment=CELERYD_NODE=daiquiri_download Environment=CELERYD_QUEUE=download Environment=CELERYD_CONCURRENCY=1 Environment=CELERYD_PID_FILE=/var/run/celery/daiquiri/download.pid Environment=CELERYD_LOG_FILE=/var/log/celery/daiquiri/download.log Environment=CELERYD_LOG_LEVEL=INFO ExecStart=/bin/sh -c '${CELERY_BIN} multi start ${CELERYD_NODE} \\ -A config \\ -Q ${CELERYD_QUEUE} \\ -c ${CELERYD_CONCURRENCY} \\ --pidfile=${CELERYD_PID_FILE} \\ --logfile=${CELERYD_LOG_FILE} \\ --loglevel=${CELERYD_LOG_LEVEL}' ExecStop=/bin/sh -c '${CELERY_BIN} multi stopwait ${CELERYD_NODE} \\ --pidfile=${CELERYD_PID_FILE}' ExecReload=/bin/sh -c '${CELERY_BIN} multi restart ${CELERYD_NODE} \\ -A config \\ -Q ${CELERYD_QUEUE} \\ -c ${CELERYD_CONCURRENCY} \\ --pidfile=${CELERYD_PID_FILE} \\ --logfile=${CELERYD_LOG_FILE} \\ --loglevel=${CELERYD_LOG_LEVEL}' [Install] WantedBy=daiquiri.service Then, the worker can be started and enabled as before: sudo systemctl daemon-reload sudo systemctl start daiquiri-default-worker sudo systemctl start daiquiri-query-worker sudo systemctl start daiquiri-download-worker sudo systemctl enable daiquiri-default-worker sudo systemctl enable daiquiri-query-worker sudo systemctl enable daiquiri-download-worker","title":"Asyncronous workers"},{"location":"deployment/#caching","text":"To use memcached as cache, first install it from the distribution: apt install memcached # Debian/Ubuntu yum install memcached # CentOS On CentOS memcached needs to be restricted to listen only to localhost in /etc/sysconfig/memcached : PORT=\"11211\" USER=\"memcached\" MAXCONN=\"1024\" CACHESIZE=\"64\" OPTIONS=\"-l 127.0.0.1,::1\" Then memcached can be enabled and started: systemctl start memcached systemctl enable memcached","title":"Caching"},{"location":"installation/","text":"Installation A usual installation of Daiquiri contains of a set of different components: A directory holding all the settings and customisations, custom to your installation of Daiquiri. We will call this directory app , but you can use any name you see fit. This app directory corresponds to a project in Django terms. The django-daiquiri library , which is centrally maintained, and which is installed as a packacge using pip . The application database to store the content, which is generated by the users of your Daiquiri installation. Currently, we support PostgreSQL, MySQL, MariaDB, and SQLite. A (bigger) scientific database , where the actual science data is stored. This can be MySQL, MariaDB, or PostgreSQL. A directory on your filesystem with static files to be downloaded. A RabbitMQ installation as message broker for the asyncronous queues. (Optional) An installation of WordPress to be uses as content management system . For testing and development, you can run Daiquiri using your regular user account. On a production system, a dedicated user account should be used. For this documantation we will use a user called daiquiri with the group daiquiri and the home directory /srv/daiquiri . This user can be created with: useradd -m -d /srv/daiquiri -c \"Daiquiri user\" -s /bin/bash daiquiri Do not use the root user to run Daiquiri! It is a bad idea anyway and several steps of the installation will not work. sudo is used in the installation when needing root-privileges to install packages. Prerequisites Although, most dependencies are installed from the Python Package Index, some dependecies need to be installed using the operation systems packages manager. Here we document the minimum prerequisites: # Centos yum install -y \\ epel-release \\ git \\ gcc gcc-c++ \\ libxml2-devel libxslt-devel \\ openssl-devel \\ python3-devel # Debian or Ubuntu apt-get install -y \\ git \\ build-essential \\ libxml2-dev libxslt-dev \\ zlib1g-dev \\ libssl-dev \\ python3-dev \\ python3-venv Obtaining the app directory The next step is to create the app directory by cloning the corresponding repository. git clone https://github.com/django-daiquiri/app Note that this is not the main django-daiquiri repository, only the configuration files. Inside this directory, you will find: a config directory, containing the main settings of your Daiquiri installation, a manage.py script, which is the main way to interact with your Daiquiri installation on the command line. Most of the following steps will use this script. Install Python packages After you have obtained the app , you need to install the django-daiquiri package and the other python dependencies. Change to the app directory and create a Virtual Environment (this is done as your user or the created daiquiri user, not as root ): cd app python3 -m venv env source env/bin/activate pip install --upgrade pip setuptools wheel After the virtual environment is activated, the django-daiquiri package can be installed using pip : pip install django-daiquiri If you want to install the current master branch directly from GutHub, you alternatively use: pip install git+https://github.com/django-daiquiri/daiquiri The virtual environment encapsulates your Daiquiri installation from the rest of the system. This makes it possible to run several applications with different python dependencies on one machine and to install the dependencies without root permissions. Important: The virtual enviroment needs to be activated, using source env/bin/activate everytime a new terminal is used. This can be automated using your .bashrc . Basic setup The settings of a Daiquiri application are specified in two files: config/settings/base.py should be part of the app repository and holds the basic settings for this particular site. .env is excluded from the repository and should contain (possible secret information) about this machine. This file will be different on the development and the production system. To set up the application, you need to create a new file .env in your cloned app directory. You can use .env.sample as template, i.e.: cp .env.sample .env The different settings are explained in detail later in the documentation . For a minimal configuration, you need to set SECRET_KEY=<a secret random string> SITE_URL=http://localhost:8000 DEBUG=True ASYNC=False DATABASE_DEFAULT=postgresql://<user>:<pass>@<host>/<db> DATABASE_DATA=postgresql://<user>:<pass>@<host>/<db> FILES_BASE_PATH=files QUERY_DOWNLOAD_DIR=download QUERY_UPLOAD_DIR=upload Databases As mentioned earlier, Daiquiri uses two separate database connections, one for the web application ( default ) and one for the scientific data ( data ). These database can be on different machines and you can even use MySQL for one and PostgreSQL for the other. For an SQLite3 database use sqlite:///database.sqlite3 to create the database in the app directory. For PostgreSQL and peer auth use postgresql://@/<db> . In order to use the different database connections, install the corresponding package with pip : pip install psycopg2-binary # for PostgreSQL pip install mysqlclient # for MySQL or MariaDB In your virtualenv, you can get the, which you need to perform on your database with the sqlcreate command: python manage.py sqlcreate Initialization After editing the settings, initialize the application using: python manage.py migrate # initializes the web database python manage.py migrate --database tap # initializes the tap schema in the scientific db python manage.py migrate --database oai # initializes the oai schema in the scientific db python manage.py createsuperuser # creates an admin user python manage.py download_vendor_files # dowloads front-end files from the CDN After these steps, Daiquiri can be run using Django\u2019s intergrated development server: python manage.py runserver Then, Daiquiri is available on http://127.0.0.1:8000 in your (local) browser. Asyncronous tasks Several tasks in Daiquiri can make use of asyncronous tasks (e.g. scientic database queries). Daiquiri can be used without asyncronous tasks, but for any deployment setup this functionality is recomended. RabbiMQ needs to be installed for asyncronous tasks to work. For Debian and Ubuntu, RabbitMQ can be installed from the distribution: apt-get install rabbitmq-server For Centos 7/8, the offical repo needs to be installed as well as its erlang dependencies. This can be done from packagecloud.io : # see also https://www.rabbitmq.com/install-rpm.html curl -s https://packagecloud.io/install/repositories/rabbitmq/erlang/script.rpm.sh | sudo bash curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.rpm.sh | sudo bash yum install rabbitmq-server systemctl start rabbitmq-server systemctl enable rabbitmq-server The asyncronous tasks can be activated the .env file of your Daiquiri application: ASYNC=True For a more complicated RabbitMQ setup the CELERY_BROKER_URL setting is used as explained here . Daiquiri uses 3 different workers: default : For miscanelous database queries performed by users. query : For asynconous database queriesperformed by users. download : For the server-side creation of download files and zip archives. In a development setup these workers can be started using: python manage.py runworker default python manage.py runworker query python manage.py runworker download in your virtual app.","title":"Installation"},{"location":"installation/#installation","text":"A usual installation of Daiquiri contains of a set of different components: A directory holding all the settings and customisations, custom to your installation of Daiquiri. We will call this directory app , but you can use any name you see fit. This app directory corresponds to a project in Django terms. The django-daiquiri library , which is centrally maintained, and which is installed as a packacge using pip . The application database to store the content, which is generated by the users of your Daiquiri installation. Currently, we support PostgreSQL, MySQL, MariaDB, and SQLite. A (bigger) scientific database , where the actual science data is stored. This can be MySQL, MariaDB, or PostgreSQL. A directory on your filesystem with static files to be downloaded. A RabbitMQ installation as message broker for the asyncronous queues. (Optional) An installation of WordPress to be uses as content management system . For testing and development, you can run Daiquiri using your regular user account. On a production system, a dedicated user account should be used. For this documantation we will use a user called daiquiri with the group daiquiri and the home directory /srv/daiquiri . This user can be created with: useradd -m -d /srv/daiquiri -c \"Daiquiri user\" -s /bin/bash daiquiri Do not use the root user to run Daiquiri! It is a bad idea anyway and several steps of the installation will not work. sudo is used in the installation when needing root-privileges to install packages.","title":"Installation"},{"location":"installation/#prerequisites","text":"Although, most dependencies are installed from the Python Package Index, some dependecies need to be installed using the operation systems packages manager. Here we document the minimum prerequisites: # Centos yum install -y \\ epel-release \\ git \\ gcc gcc-c++ \\ libxml2-devel libxslt-devel \\ openssl-devel \\ python3-devel # Debian or Ubuntu apt-get install -y \\ git \\ build-essential \\ libxml2-dev libxslt-dev \\ zlib1g-dev \\ libssl-dev \\ python3-dev \\ python3-venv","title":"Prerequisites"},{"location":"installation/#obtaining-the-app-directory","text":"The next step is to create the app directory by cloning the corresponding repository. git clone https://github.com/django-daiquiri/app Note that this is not the main django-daiquiri repository, only the configuration files. Inside this directory, you will find: a config directory, containing the main settings of your Daiquiri installation, a manage.py script, which is the main way to interact with your Daiquiri installation on the command line. Most of the following steps will use this script.","title":"Obtaining the app directory"},{"location":"installation/#install-python-packages","text":"After you have obtained the app , you need to install the django-daiquiri package and the other python dependencies. Change to the app directory and create a Virtual Environment (this is done as your user or the created daiquiri user, not as root ): cd app python3 -m venv env source env/bin/activate pip install --upgrade pip setuptools wheel After the virtual environment is activated, the django-daiquiri package can be installed using pip : pip install django-daiquiri If you want to install the current master branch directly from GutHub, you alternatively use: pip install git+https://github.com/django-daiquiri/daiquiri The virtual environment encapsulates your Daiquiri installation from the rest of the system. This makes it possible to run several applications with different python dependencies on one machine and to install the dependencies without root permissions. Important: The virtual enviroment needs to be activated, using source env/bin/activate everytime a new terminal is used. This can be automated using your .bashrc .","title":"Install Python packages"},{"location":"installation/#basic-setup","text":"The settings of a Daiquiri application are specified in two files: config/settings/base.py should be part of the app repository and holds the basic settings for this particular site. .env is excluded from the repository and should contain (possible secret information) about this machine. This file will be different on the development and the production system. To set up the application, you need to create a new file .env in your cloned app directory. You can use .env.sample as template, i.e.: cp .env.sample .env The different settings are explained in detail later in the documentation . For a minimal configuration, you need to set SECRET_KEY=<a secret random string> SITE_URL=http://localhost:8000 DEBUG=True ASYNC=False DATABASE_DEFAULT=postgresql://<user>:<pass>@<host>/<db> DATABASE_DATA=postgresql://<user>:<pass>@<host>/<db> FILES_BASE_PATH=files QUERY_DOWNLOAD_DIR=download QUERY_UPLOAD_DIR=upload","title":"Basic setup"},{"location":"installation/#databases","text":"As mentioned earlier, Daiquiri uses two separate database connections, one for the web application ( default ) and one for the scientific data ( data ). These database can be on different machines and you can even use MySQL for one and PostgreSQL for the other. For an SQLite3 database use sqlite:///database.sqlite3 to create the database in the app directory. For PostgreSQL and peer auth use postgresql://@/<db> . In order to use the different database connections, install the corresponding package with pip : pip install psycopg2-binary # for PostgreSQL pip install mysqlclient # for MySQL or MariaDB In your virtualenv, you can get the, which you need to perform on your database with the sqlcreate command: python manage.py sqlcreate","title":"Databases"},{"location":"installation/#initialization","text":"After editing the settings, initialize the application using: python manage.py migrate # initializes the web database python manage.py migrate --database tap # initializes the tap schema in the scientific db python manage.py migrate --database oai # initializes the oai schema in the scientific db python manage.py createsuperuser # creates an admin user python manage.py download_vendor_files # dowloads front-end files from the CDN After these steps, Daiquiri can be run using Django\u2019s intergrated development server: python manage.py runserver Then, Daiquiri is available on http://127.0.0.1:8000 in your (local) browser.","title":"Initialization"},{"location":"installation/#asyncronous-tasks","text":"Several tasks in Daiquiri can make use of asyncronous tasks (e.g. scientic database queries). Daiquiri can be used without asyncronous tasks, but for any deployment setup this functionality is recomended. RabbiMQ needs to be installed for asyncronous tasks to work. For Debian and Ubuntu, RabbitMQ can be installed from the distribution: apt-get install rabbitmq-server For Centos 7/8, the offical repo needs to be installed as well as its erlang dependencies. This can be done from packagecloud.io : # see also https://www.rabbitmq.com/install-rpm.html curl -s https://packagecloud.io/install/repositories/rabbitmq/erlang/script.rpm.sh | sudo bash curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.rpm.sh | sudo bash yum install rabbitmq-server systemctl start rabbitmq-server systemctl enable rabbitmq-server The asyncronous tasks can be activated the .env file of your Daiquiri application: ASYNC=True For a more complicated RabbitMQ setup the CELERY_BROKER_URL setting is used as explained here . Daiquiri uses 3 different workers: default : For miscanelous database queries performed by users. query : For asynconous database queriesperformed by users. download : For the server-side creation of download files and zip archives. In a development setup these workers can be started using: python manage.py runworker default python manage.py runworker query python manage.py runworker download in your virtual app.","title":"Asyncronous tasks"},{"location":"settings/","text":"Settings A Daiquiri application can be customised using various settings. Since Daiquiri is based on Django, we use its build-in settings system . Almost every setting has a default value, which is set in the Daiquiri library. The core settings are defined in the daiquiri.core.settings module: daiquiri.core.settings.django daiquiri.core.settings.celery daiquiri.core.settings.daiquiri daiquiri.core.settings.logging daiquiri.core.settings.vendor Additional settings, which concern only a single Daiquiri module are defined in the settings module of the particular module: daiquiri.archive.settings daiquiri.auth.settings daiquiri.conesearch.settings daiquiri.cutout.settings daiquiri.files.settings daiquiri.meetings.settings daiquiri.metadata.settings daiquiri.oai.settings daiquiri.query.settings daiquiri.serve.settings daiquiri.stats.settings daiquiri.tap.settings daiquiri.wordpress.settings All settings can be changed for your particular app in config/settings/base.py (app specific) or config/settings/local.py (machine specific, and ignored by git). In addition, selected settings can be configured as environment variables, in particular using the .env file app directory: Setting Default SECRET_KEY \ud83d\udeab SITE_URL http://localhost:8000 DEBUG False ASYNC False ALLOWED_HOSTS ['localhost'] TIME_ZONE 'UTC' PROXY False ADMINS [] DATABASE_APP \ud83d\udeab DATABASE_DATA \ud83d\udeab TAP_SCHEMA TAP_SCHEMA TAP_UPLOAD TAP_UPLOAD OAI_SCHEMA OAI_SCHEMA In the .env file, lists are seperated by comma, e.g. ADMINS=Anna Admin <admin@example.com>, Manni Manager <manager@example.com> . Since SECRET_KEY , DATABASE_APP , and DATABASE_DATA have no default value, they need to be set in any case. In the following all settings, which can be changed from their default values to customize you particular Daiquiri app are described in detail: daiquiri.core.settings.django SECRET_KEY Secret key for Django. See also SECRET_KEY in the Django documentation. Should be set in .env . DEBUG Default: False Debug mode. See also DEBUG in the Django documentation. Should be set in .env . BASE_URL Default: / Base URL for the Daiquiri app. Set if your Daiquiri app runs under a alias path on your web server, e.g. /daiquiri/ . ALLOWED_HOSTS Default: ['localhost'] List of allowed hosts for this app. See also ALLOWED_HOSTS in the Django documentation. Should be set in .env . TIME_ZONE Default: 'UTC' The time zone for this Daiquiri app (e.g. Europe/Berlin ). ACCOUNT_LOGOUT_ON_GET Default: False Designates if a GET request is sufficient to logout. The seeting needs to be set to TRUE if the WordPress integration is used. ACCOUNT_USERNAME_MIN_LENGTH Default: 4 The minimal length of usernames. ACCOUNT_PASSWORD_MIN_LENGTH Default: 4 The minimal length of passwords. ACCOUNT_EMAIL_VERIFICATION Default: 'mandatory' Designates if new users need to verify their email addresses before logging in. Options are 'mandatory' 'optional' 'none' See also ACCOUNT_EMAIL_VERIFICATION in the django-allauth documentation. ACCOUNT_LOGIN_ON_EMAIL_CONFIRMATION Default: True Designates if new users are automatically logged in after validating their email address. REST_FRAMEWORK Default: { 'DEFAULT_THROTTLE_CLASSES': ( 'rest_framework.throttling.ScopedRateThrottle', ), 'DEFAULT_THROTTLE_RATES': { 'query.create': '10/second' } } Configuration object for the Django REST framework. Used to adjust the maximum rate in which queries are allowed to be submitted (by anyone). See also Throttling in the Django REST framework documentation. EMAIL_BACKEND Default: 'django.core.mail.backends.console.EmailBackend' Sets the backend used for email delivery. On a production system, this will be django.core.mail.backends.smtp.EmailBackend . For testing/demonstration django.core.mail.backends.console.EmailBackend can be used. See also Sending email in the Django documentation. Can be set in .env . EMAIL_HOST Default: 'localhost' Hostname of the SMTP server. Can be set in .env . EMAIL_PORT Default: '25' Port of the SMTP server. Can be set in .env . EMAIL_HOST_USER Default: '' User for the SMTP server. Can be set in .env . EMAIL_HOST_PASSWORD Default: '' Password for the SMTP server. Can be set in .env . EMAIL_USE_TLS Default: False Designates whether a STARTTLS is used (usually on port 587). Can be set in .env . EMAIL_USE_SSL Default: False Designates whether a implicit TLS connection is used (usually on port 465). Can be set in .env . DEFAULT_FROM_EMAIL Default: '' Sets the FROM field for the E-mails send. Can be set in .env . SENDFILE_BACKEND Default: 'sendfile.backends.simple' Sets the backend used for the sendfile integration to deliver static files. On a production system (using Apache), this will be sendfile.backends.xsendfile . For testing/demonstration sendfile.backends.simple can be used. See also Django Sendfile GitHub readme. MEMCACHE_KEY_PREFIX Default: None Key prefix to use for caching with memcached . Enables caching with memcached. See also deployment . Should be set in .env . daiquiri.core.settings.daiquiri ASYNC Default: False Designates if celery workers are used for asyncronous tasks like query execution. If set to True , three workers need to run: default , query , and download . IPV4_PRIVACY_MASK Default: 16 Number of bits kept from IPv4 addresses (e.g. to produce query stats) for anonymity. IPV6_PRIVACY_MASK Default: 32 Number of bits kept from IPv6 addresses (e.g. to produce query stats) for anonymity. SITE_URL Default: http://localhost:8000 Public URL of the Daiquiri site. Used for VO and OAI metadata. SITE_IDENTIFIER Default: None Identifier for the Daiquiri site. Usually the URL without the protocol. Used for VO and OAI metadata. SITE_TITLE Default: None The title for the Daiquiri site. Used for VO and OAI metadata. SITE_DESCRIPTION Default: None The description for the Daiquiri site. Used for VO and OAI metadata. SITE_LICENSE Default: None A license for the Daiquiri site. See https://github.com/django-daiquiri/daiquiri/blob/master/daiquiri/core/constants.py for the available choices. Used in various metadata fields. SITE_CREATOR Default: None Creator of the Daiquiri site. Used in the VO registry entry. Has to be of the following form: { 'name': 'Daiquiri project' 'logo': None } SITE_CONTACT Default: None List of contacts for the Daiquiri site. Used in the VO registry entry. Has to be of the following form: { 'name': 'Anna Admin' 'address': 'Beispielstr. 3, 12345 Berlin', 'email': 'contact@example.com' 'telephone': '+49 30 123467' } SITE_PUBLISHER Default: None Publisher of the Daiquiri site. Used for VO and OAI metadata. SITE_CREATED Default: None Date of the creation of the Daiquiri site. Used for VO and OAI metadata. Has to be of the form YYYY-MM-DD . SITE_UPDATED Default: None Date of the last update of the Daiquiri site. Used for VO and OAI metadata. Has to be of the form YYYY-MM-DD . SITE_SUBJECTS Default: [ { 'subject': 'Astronomy', 'schemeURI': 'http://id.loc.gov/authorities/subjects', 'valueURI': 'http://id.loc.gov/authorities/subjects/sh85009003' } ] Subjects for this Daiquiri app. Used for VO and OAI metadata. SITE_TYPE Default: 'service' Type for this Daiquiri site. Used in the VO registry entry. daiquiri.core.settings.celery CELERY_BROKER_URL Default: amqp:// URL of the RabbitMQ server to be used. For a more sophisticated setup use: CELERY_BROKER_URL=amqp://<user>:<password>@<host>:<port>/<vhost> See also deployment . Should be set in .env . daiquiri.core.settings.logging LOG_LEVEL Default: INFO Level of logging. Set to DEBUG to get more verbose logging. Should be set in .env . LOG_DIR Default: None Directory for log files. In development log is suitable, in production /var/log/django/daiquiri/ might be a sensible choice. Note that this directory must exist for Daiquiri to work. Should be set in .env . daiquiri.core.settings.vendor VENDOR_CDN Default: False Use content delivery networks to host the static vendor assets (js and css files). Using the default of False implies that the assets need to be collected using python manage.py download_vendor_files . daiquiri.archive.settings ARCHIVE_BASE_PATH Default: os.path.join(BASE_DIR, 'files') Sets the absolute base path of the files served by the archive module in the local file system. ARCHIVE_DOWNLOAD_DIR Default: os.path.join(BASE_DIR, 'download') Sets the absolute path where the zip files for downloads from the archive are located in the local file system. ARCHIVE_ANONYMOUS Default: False Designates if the archive interface can be accessed by anonymus users. ARCHIVE_SCHEMA Default: 'daiquiri_archive' Sets the schema for the archive in the data database. ARCHIVE_TABLE Default: 'files' Sets the table for the archive in the schema set by ARCHIVE_SCHEMA the data database. ARCHIVE_COLUMNS Default: [ { 'name': 'id', 'hidden': True }, { 'name': 'timestamp', 'label': 'Timestamp' }, { 'name': 'file', 'label': 'Filename', 'ucd': 'meta.file' }, { 'name': 'collection', 'hidden': True }, { 'name': 'path', 'hidden': True } ] Sets the additional columns for the archive in the table set by ARCHIVE_TABLE the data database. daiquiri.auth.settings AUTH_SIGNUP Default: False Designates if users can register for an account. If set to false, all users need to be created through the Django admin system. AUTH_WORKFLOW Default: None Sets the workflow for user registration. Options are None : Newly registered users can log in after registartion. 'activation' : Newly registered users need to be activated by a manager or admin. 'confirmation' : Newly registered users need to be confirmed by a manager before they are activated by an admin. AUTH_DETAIL_KEYS Default: [] Sets additional details to be asked from the users when registering. An example would be: AUTH_DETAIL_KEYS = [ { 'key': 'affiliation', 'label': 'Affiliation', 'data_type': 'text', 'required': True, 'options': [] }, ] where: key is the internal identifier, label the text shown in the interface, datatype the type of the detail which affects the widget to be used ( 'text' , 'textarea' , 'select' , 'radio' , 'multiselect' , or 'checkbox' ), required whether this detail is required or not, and options a list of options for select, radio or checkboxes widgets of the form [{'id': id, 'label': label}, ...] . AUTH_TERMS_OF_USE Default: False Designates whether terms of use are displayed on the signup page and need to be accepted to register. The text of to displayed needs to be configured in a template account/terms_of_use.html . daiquiri.cutout.settings CONESEARCH_ADAPTER Default: 'daiquiri.conesearch.adapter.SimpleConeSearchAdapter' Sets the adapter class to be used by the cone search api. The adapter class encapsulated all operations creating a cone search votable output from the api request. Custom adapter need to enherit from daiquiri.conesearch.adapter.BaseConeSearchAdapter . CONESEARCH_ANONYMOUS Default: False Designates if cone searches can be done by by anonymus users. daiquiri.cutout.settings CUTOUT_ADAPTER Default: 'daiquiri.cutout.adapter.SimpleCutOutAdapter' Sets the adapter class to be used by the cutout api. The adapter class encapsulated all operations creating a cut out from the api request. Custom adapter need to enherit from daiquiri.cutout.adapter.BaseCutOutAdapter . CUTOUT_ANONYMOUS Default: False Designates if the cutout interface can be accessed by anonymus users. daiquiri.files.settings FILES_BASE_PATH Default: os.path.join(BASE_DIR, 'files') Sets the absolute base path of the files served by the files module in the local file system. Should be set in .env . FILES_BASE_URL Default: None Sets the absolute URL for this Daiquiri app to be prepended to file references when downloading query results. This is done for columns with the meta.ref;meta.file , meta.ref;meta.image or meta.ref;meta.note UCD. Should be set in .env . daiquiri.meetings.settings MEETINGS_CONTRIBUTION_TYPES Default: [ ('talk', _('Talk')), ('poster', _('Poster')) ] Sets the types of contributions to be selected by partcipants when registering. MEETINGS_PAYMENT_CHOICES Default: [ ('cash', _('cash')), ('wire', _('wire transfer')), ] Sets the different payment choices to be selected by partcipants when registering. MEETINGS_PARTICIPANT_DETAIL_KEYS Default: [] Sets additional details to be asked from the participants when registering. An example would be: MEETINGS_PARTICIPANT_DETAIL_KEYS = [ { 'key': 'affiliation', 'label': 'Affiliation', 'data_type': 'text', 'required': True }, { 'key': 'dinner', 'label': 'Conference dinner', 'data_type': 'radio', 'required': True, 'options': [ {'id': 'yes', 'label': 'yes'}, {'id': 'no', 'label': 'no'} ] } ] where: key is the internal identifier, label the text shown in the interface, datatype the type of the detail which affects the widget to be used ( 'text' , 'textarea' , 'select' , 'radio' , 'multiselect' , or 'checkbox' ), required whether this detail is required or not, and options a list of options for select, radio or checkboxes widgets of the form [{'id': id, 'label': label}, ...] . MEETINGS_ABSTRACT_MAX_LENGTH Default: 2000 Sets the maximum lenght of an abstract. daiquiri.metadata.settings METADATA_COLUMN_PERMISSIONS Default: False Designates if permissions can be assigned to individual columns (in addition to tables and schemas). This is an experimental feature. METADATA_BASE_URL Default: None Sets the absolute URL of the metadata module, e.g. http://example.com/metadata/. The URL is used to create links to the landing pages for schemas and tables in VOTables if a DOI is not set. daiquiri.oai.settings OAI_SCHEMA Default: OAI_SCHEMA Sets the name of the schema for OAI records. If more than one Daiquiri application is using the same data database, they cannot use the same OAI_SCHEMA schema. This setting must be set in .env OAI_ADAPTER Default: 'daiquiri.metadata.adapter.RegistryDoiMetadataOaiAdapter' Sets the adapter class to be used by the OAI-PMH api. The adapter class encapsulated all operations to set up and retrieve the OAI records. Custom adapter need to enherit from daiquiri.metadata.adapter.BaseOaiAdapter . Usually this will be done in the Daiquiri app, e.g. OAI_ADAPTER = 'app.adapter.OaiAdapter' OAI_PAGE_SIZE Default: 500 Number of records returned in a OAI-PMH request. daiquiri.query.settings QUERY_ANONYMOUS Default: False Designates if the query interface can be accessed by anonymus users. The permissions on schemas and tables need to be configured using the metadata interface. QUERY_USER_SCHEMA_PREFIX Default: 'daiquiri_user_' Sets the prefix for user schemas in the data database. Each user has a private schema where the result table of successful queries are stored. QUERY_QUOTA Default: { 'anonymous': '100Mb', 'user': '10000Mb', 'users': {}, 'groups': {} } Sets the maximum quota for tables in a user\u2019s personal schema. The quota need to be set for the anonymous user as well as regular loggen in users ( user ). Additionally, users or groups can be asigned individual quotas, e.g.: { 'anonymous': '100Mb', 'user': '10000Mb', 'users': { 'admin': '1000Gb' }, 'groups': { 'collab': '100Gb' } } If more than one quota applies, the maximum is used. QUERY_SYNC_TIMEOUT Default: 5 Sets the timeout for syncronous (TAP) queries in seconds. QUERY_MAX_ACTIVE_JOBS Default: { 'anonymous': '1' } Sets the maximum of simultanous jobs for users. The setting work analog to \u2018QUERY_QUOTA\u2019. If more than one maximum applies, the maximum is used. If no maximum is given, like the default setting for logged users, no maximum is enforced. QUERY_QUEUES Default: [ { 'key': 'default', 'label': 'Default', 'timeout': 10, 'priority': 1, 'access_level': 'PUBLIC', 'groups': [] } ] Set the different queue, which can be selected by the users. Each queue is represented by a dictionary where: key is the internal identifier, label is the text shown in the interface, timeout the maximum excecution time in seconds, priority is a integer number indicationg the priority in which jobs are executed, and access_level and groups the usual restiction on who can use this queue. Jobs in a queue with higher priority are selected first when a query worker becomes available. QUERY_LANGUAGES Default: [ { 'key': 'adql', 'version': 2.0, 'label': 'ADQL', 'description': '', 'quote_char': '\"' } ] Sets the different query languages, which can be selected by the users. Each query language is represented by a dictionary where: key is the internal identifier, label is the text shown in the interface, description is additional information shown, e.g. in TopCat, and quote_char the character used by the database system to quote identifiers. Already implemented in Daiquiri are adql , postgresql , and mysql . Apart from ADQL, the query language must match the database system of the data database. QUERY_FORMS Default: [ { 'key': 'sql', 'label': 'SQL query', 'service': 'query/js/forms/sql.js', 'template': 'query/query_form_sql.html' } ] Sets the form available for the users in the query interface. Each form is represented by a dictionary where: key is the internal identifier, label is the text shown in the interface, service the path AngularJS service containing the client side logic, and template the path to the Django template with the markup for the form. Included in Daiquiri are sql and (simplyfied) cone and box services. QUERY_DROPDOWNS Default: [ { 'key': 'simbad', 'service': 'query/js/dropdowns/simbad.js', 'template': 'query/query_dropdown_simbad.html', 'options': { 'url': 'http://simbad.u-strasbg.fr/simbad/sim-id' } }, { 'key': 'vizier', 'service': 'query/js/dropdowns/vizier.js', 'template': 'query/query_dropdown_vizier.html', 'options': { 'url': 'http://vizier.u-strasbg.fr/viz-bin/votable', 'catalogs': ['I/322A', 'I/259'] } } ] Sets the additional drop down menus above the SQL query interface available for the users. Each drop down is represented by a dictionary where: key is the internal identifier, service the path AngularJS service containing the client side logic, template the path to the Django template with the markup, and options additional options specific to the drop down. Included in Daiquiri are simbad and vizier services. QUERY_DOWNLOAD_DIR Default: os.path.join(BASE_DIR, 'download') Sets the absolute base path of the download files served by the query module in the local file system. QUERY_DEFAULT_DOWNLOAD_FORMAT Default: 'votable' Sets the default download format. QUERY_DOWNLOAD_FORMATS Default: [ { 'key': 'votable', 'extension': 'xml', 'content_type': 'application/xml', 'label': 'IVOA VOTable XML file - TABLEDATA serialization', 'help': 'A XML file using the IVOA VOTable format. Use this option if you intend to use VO compatible software to further process the data.' }, { 'key': 'csv', 'extension': 'csv', 'content_type': 'text/csv', 'label': 'Comma separated Values', 'help': 'A text file with a line for each row of the table. The fields are delimited by a comma and quoted by double quotes. Use this option for a later import into a spreadsheed application or a custom script. Use this option if you are unsure what to use.' }, { 'key': 'fits', 'extension': 'fits', 'content_type': 'application/fits', 'label': 'FITS', 'help': 'Flexible Image Transport System (FITS) file format.' } ] Sets the available default download formats. Each format is represented by a dictionary where: key is the internal identifier, extension the file extension, content_type the content type, label the text shown in the interface, and help a more verbose help text for the format. QUERY_UPLOAD Default: True Enables the upload functionality in the query interface. QUERY_UPLOAD_LIMIT Default: { 'anonymous': '10Mb', 'user': '100Mb', 'users': {}, 'groups': {} } Sets the maximum quota for uploads by a user. The quota need to be set for the anonymous user as well as regular loggen in users ( user ). Additionally, users or groups can be asigned individual quotas, much like with QUERY_QUOTA . daiquiri.serve.settings SERVE_DOWNLOAD_DIR Default: os.path.join(BASE_DIR, 'download') Sets the absolute base path of the download files served by the serve module in the local file system. SERVE_RESOLVER Default: None Sets the a resolver class to handle references in tables served by the serve module. daiquiri.stats.settings STATS_RESOURCE_TYPES Default: [ { 'key': 'ARCHIVE_DOWNLOAD', 'label': 'Archive downloads' }, { 'key': 'CONESEARCH', 'label': 'Performed cone searches' }, { 'key': 'CUTOUT', 'label': 'Performed cutouts' }, { 'key': 'FILE', 'label': 'File downloads' }, { 'key': 'QUERY', 'label': 'Queries' } ] Sets the aggegated stats shown in the stats management overview. daiquiri.tap.settings TAP_SCHEMA Default: 'TAP_SCHEMA' Sets the name of the TAP schema. If more than one Daiquiri application is using the same data database, they cannot use the same TAP schema. Therefore the schema name TAP_SCHEMA is replaced before queries are submitted. This setting must be set in .env TAP_UPLOAD Default: 'TAP_UPLOAD' Sets the name of the schema for TAP uploads. If more than one Daiquiri application is using the same data database, they cannot use the same TAP_UPLOAD schema. Therefore the schema name TAP_UPLOAD is replaced before queries are submitted. This setting must be set in .env daiquiri.uws.settings UWS_RESOURCES Default: [] Configures UWS services (in addition to the TAP module). E.g.: { 'prefix': r'query', 'viewset': 'daiquiri.query.viewsets.UWSQueryJobViewSet', 'base_name': 'uws_query' } where: prefix is part of the base URL of the service (e.g. http://example.com/usw/query), viewset is the ViewSet class handling the requests (neets to enherit from daiquiri.jobs.viewsets.AsyncJobViewSet ), and base_name a basename needed for the integration in the Django REST framework. daiquiri.wordpress.settings WORDPRESS_PATH Default: '/opt/wordpress' Sets the location of the WordPress installation on the local file system. WORDPRESS_SSH Default: None Sets the destination for a SSH connection to use with wp-cli . Use this setting if WordPress is not installed on the same host as Daiquiri. The local wp-cli will then connect to the remote system using ssh. An example would be: WORDPRESS_SSH=example.com:/opt/daiquiri This option overided WORDPRESS_PATH . WORDPRESS_CLI Default: '/opt/wp-cli/wp' Sets the location of the wp-cli script on the local file system. WORDPRESS_URL Default: '/cms/' Sets the base url of the WordPress instance.","title":"Settings"},{"location":"settings/#settings","text":"A Daiquiri application can be customised using various settings. Since Daiquiri is based on Django, we use its build-in settings system . Almost every setting has a default value, which is set in the Daiquiri library. The core settings are defined in the daiquiri.core.settings module: daiquiri.core.settings.django daiquiri.core.settings.celery daiquiri.core.settings.daiquiri daiquiri.core.settings.logging daiquiri.core.settings.vendor Additional settings, which concern only a single Daiquiri module are defined in the settings module of the particular module: daiquiri.archive.settings daiquiri.auth.settings daiquiri.conesearch.settings daiquiri.cutout.settings daiquiri.files.settings daiquiri.meetings.settings daiquiri.metadata.settings daiquiri.oai.settings daiquiri.query.settings daiquiri.serve.settings daiquiri.stats.settings daiquiri.tap.settings daiquiri.wordpress.settings All settings can be changed for your particular app in config/settings/base.py (app specific) or config/settings/local.py (machine specific, and ignored by git). In addition, selected settings can be configured as environment variables, in particular using the .env file app directory: Setting Default SECRET_KEY \ud83d\udeab SITE_URL http://localhost:8000 DEBUG False ASYNC False ALLOWED_HOSTS ['localhost'] TIME_ZONE 'UTC' PROXY False ADMINS [] DATABASE_APP \ud83d\udeab DATABASE_DATA \ud83d\udeab TAP_SCHEMA TAP_SCHEMA TAP_UPLOAD TAP_UPLOAD OAI_SCHEMA OAI_SCHEMA In the .env file, lists are seperated by comma, e.g. ADMINS=Anna Admin <admin@example.com>, Manni Manager <manager@example.com> . Since SECRET_KEY , DATABASE_APP , and DATABASE_DATA have no default value, they need to be set in any case. In the following all settings, which can be changed from their default values to customize you particular Daiquiri app are described in detail:","title":"Settings"},{"location":"settings/#daiquiricoresettingsdjango","text":"","title":"daiquiri.core.settings.django"},{"location":"settings/#secret_key","text":"Secret key for Django. See also SECRET_KEY in the Django documentation. Should be set in .env .","title":"SECRET_KEY"},{"location":"settings/#debug","text":"Default: False Debug mode. See also DEBUG in the Django documentation. Should be set in .env .","title":"DEBUG"},{"location":"settings/#base_url","text":"Default: / Base URL for the Daiquiri app. Set if your Daiquiri app runs under a alias path on your web server, e.g. /daiquiri/ .","title":"BASE_URL"},{"location":"settings/#allowed_hosts","text":"Default: ['localhost'] List of allowed hosts for this app. See also ALLOWED_HOSTS in the Django documentation. Should be set in .env .","title":"ALLOWED_HOSTS"},{"location":"settings/#time_zone","text":"Default: 'UTC' The time zone for this Daiquiri app (e.g. Europe/Berlin ).","title":"TIME_ZONE"},{"location":"settings/#account_logout_on_get","text":"Default: False Designates if a GET request is sufficient to logout. The seeting needs to be set to TRUE if the WordPress integration is used.","title":"ACCOUNT_LOGOUT_ON_GET"},{"location":"settings/#account_username_min_length","text":"Default: 4 The minimal length of usernames.","title":"ACCOUNT_USERNAME_MIN_LENGTH"},{"location":"settings/#account_password_min_length","text":"Default: 4 The minimal length of passwords.","title":"ACCOUNT_PASSWORD_MIN_LENGTH"},{"location":"settings/#account_email_verification","text":"Default: 'mandatory' Designates if new users need to verify their email addresses before logging in. Options are 'mandatory' 'optional' 'none' See also ACCOUNT_EMAIL_VERIFICATION in the django-allauth documentation.","title":"ACCOUNT_EMAIL_VERIFICATION"},{"location":"settings/#account_login_on_email_confirmation","text":"Default: True Designates if new users are automatically logged in after validating their email address.","title":"ACCOUNT_LOGIN_ON_EMAIL_CONFIRMATION"},{"location":"settings/#rest_framework","text":"Default: { 'DEFAULT_THROTTLE_CLASSES': ( 'rest_framework.throttling.ScopedRateThrottle', ), 'DEFAULT_THROTTLE_RATES': { 'query.create': '10/second' } } Configuration object for the Django REST framework. Used to adjust the maximum rate in which queries are allowed to be submitted (by anyone). See also Throttling in the Django REST framework documentation.","title":"REST_FRAMEWORK"},{"location":"settings/#email_backend","text":"Default: 'django.core.mail.backends.console.EmailBackend' Sets the backend used for email delivery. On a production system, this will be django.core.mail.backends.smtp.EmailBackend . For testing/demonstration django.core.mail.backends.console.EmailBackend can be used. See also Sending email in the Django documentation. Can be set in .env .","title":"EMAIL_BACKEND"},{"location":"settings/#email_host","text":"Default: 'localhost' Hostname of the SMTP server. Can be set in .env .","title":"EMAIL_HOST"},{"location":"settings/#email_port","text":"Default: '25' Port of the SMTP server. Can be set in .env .","title":"EMAIL_PORT"},{"location":"settings/#email_host_user","text":"Default: '' User for the SMTP server. Can be set in .env .","title":"EMAIL_HOST_USER"},{"location":"settings/#email_host_password","text":"Default: '' Password for the SMTP server. Can be set in .env .","title":"EMAIL_HOST_PASSWORD"},{"location":"settings/#email_use_tls","text":"Default: False Designates whether a STARTTLS is used (usually on port 587). Can be set in .env .","title":"EMAIL_USE_TLS"},{"location":"settings/#email_use_ssl","text":"Default: False Designates whether a implicit TLS connection is used (usually on port 465). Can be set in .env .","title":"EMAIL_USE_SSL"},{"location":"settings/#default_from_email","text":"Default: '' Sets the FROM field for the E-mails send. Can be set in .env .","title":"DEFAULT_FROM_EMAIL"},{"location":"settings/#sendfile_backend","text":"Default: 'sendfile.backends.simple' Sets the backend used for the sendfile integration to deliver static files. On a production system (using Apache), this will be sendfile.backends.xsendfile . For testing/demonstration sendfile.backends.simple can be used. See also Django Sendfile GitHub readme.","title":"SENDFILE_BACKEND"},{"location":"settings/#memcache_key_prefix","text":"Default: None Key prefix to use for caching with memcached . Enables caching with memcached. See also deployment . Should be set in .env .","title":"MEMCACHE_KEY_PREFIX"},{"location":"settings/#daiquiricoresettingsdaiquiri","text":"","title":"daiquiri.core.settings.daiquiri"},{"location":"settings/#async","text":"Default: False Designates if celery workers are used for asyncronous tasks like query execution. If set to True , three workers need to run: default , query , and download .","title":"ASYNC"},{"location":"settings/#ipv4_privacy_mask","text":"Default: 16 Number of bits kept from IPv4 addresses (e.g. to produce query stats) for anonymity.","title":"IPV4_PRIVACY_MASK"},{"location":"settings/#ipv6_privacy_mask","text":"Default: 32 Number of bits kept from IPv6 addresses (e.g. to produce query stats) for anonymity.","title":"IPV6_PRIVACY_MASK"},{"location":"settings/#site_url","text":"Default: http://localhost:8000 Public URL of the Daiquiri site. Used for VO and OAI metadata.","title":"SITE_URL"},{"location":"settings/#site_identifier","text":"Default: None Identifier for the Daiquiri site. Usually the URL without the protocol. Used for VO and OAI metadata.","title":"SITE_IDENTIFIER"},{"location":"settings/#site_title","text":"Default: None The title for the Daiquiri site. Used for VO and OAI metadata.","title":"SITE_TITLE"},{"location":"settings/#site_description","text":"Default: None The description for the Daiquiri site. Used for VO and OAI metadata.","title":"SITE_DESCRIPTION"},{"location":"settings/#site_license","text":"Default: None A license for the Daiquiri site. See https://github.com/django-daiquiri/daiquiri/blob/master/daiquiri/core/constants.py for the available choices. Used in various metadata fields.","title":"SITE_LICENSE"},{"location":"settings/#site_creator","text":"Default: None Creator of the Daiquiri site. Used in the VO registry entry. Has to be of the following form: { 'name': 'Daiquiri project' 'logo': None }","title":"SITE_CREATOR"},{"location":"settings/#site_contact","text":"Default: None List of contacts for the Daiquiri site. Used in the VO registry entry. Has to be of the following form: { 'name': 'Anna Admin' 'address': 'Beispielstr. 3, 12345 Berlin', 'email': 'contact@example.com' 'telephone': '+49 30 123467' }","title":"SITE_CONTACT"},{"location":"settings/#site_publisher","text":"Default: None Publisher of the Daiquiri site. Used for VO and OAI metadata.","title":"SITE_PUBLISHER"},{"location":"settings/#site_created","text":"Default: None Date of the creation of the Daiquiri site. Used for VO and OAI metadata. Has to be of the form YYYY-MM-DD .","title":"SITE_CREATED"},{"location":"settings/#site_updated","text":"Default: None Date of the last update of the Daiquiri site. Used for VO and OAI metadata. Has to be of the form YYYY-MM-DD .","title":"SITE_UPDATED"},{"location":"settings/#site_subjects","text":"Default: [ { 'subject': 'Astronomy', 'schemeURI': 'http://id.loc.gov/authorities/subjects', 'valueURI': 'http://id.loc.gov/authorities/subjects/sh85009003' } ] Subjects for this Daiquiri app. Used for VO and OAI metadata.","title":"SITE_SUBJECTS"},{"location":"settings/#site_type","text":"Default: 'service' Type for this Daiquiri site. Used in the VO registry entry.","title":"SITE_TYPE"},{"location":"settings/#daiquiricoresettingscelery","text":"","title":"daiquiri.core.settings.celery"},{"location":"settings/#celery_broker_url","text":"Default: amqp:// URL of the RabbitMQ server to be used. For a more sophisticated setup use: CELERY_BROKER_URL=amqp://<user>:<password>@<host>:<port>/<vhost> See also deployment . Should be set in .env .","title":"CELERY_BROKER_URL"},{"location":"settings/#daiquiricoresettingslogging","text":"","title":"daiquiri.core.settings.logging"},{"location":"settings/#log_level","text":"Default: INFO Level of logging. Set to DEBUG to get more verbose logging. Should be set in .env .","title":"LOG_LEVEL"},{"location":"settings/#log_dir","text":"Default: None Directory for log files. In development log is suitable, in production /var/log/django/daiquiri/ might be a sensible choice. Note that this directory must exist for Daiquiri to work. Should be set in .env .","title":"LOG_DIR"},{"location":"settings/#daiquiricoresettingsvendor","text":"","title":"daiquiri.core.settings.vendor"},{"location":"settings/#vendor_cdn","text":"Default: False Use content delivery networks to host the static vendor assets (js and css files). Using the default of False implies that the assets need to be collected using python manage.py download_vendor_files .","title":"VENDOR_CDN"},{"location":"settings/#daiquiriarchivesettings","text":"","title":"daiquiri.archive.settings"},{"location":"settings/#archive_base_path","text":"Default: os.path.join(BASE_DIR, 'files') Sets the absolute base path of the files served by the archive module in the local file system.","title":"ARCHIVE_BASE_PATH"},{"location":"settings/#archive_download_dir","text":"Default: os.path.join(BASE_DIR, 'download') Sets the absolute path where the zip files for downloads from the archive are located in the local file system.","title":"ARCHIVE_DOWNLOAD_DIR"},{"location":"settings/#archive_anonymous","text":"Default: False Designates if the archive interface can be accessed by anonymus users.","title":"ARCHIVE_ANONYMOUS"},{"location":"settings/#archive_schema","text":"Default: 'daiquiri_archive' Sets the schema for the archive in the data database.","title":"ARCHIVE_SCHEMA"},{"location":"settings/#archive_table","text":"Default: 'files' Sets the table for the archive in the schema set by ARCHIVE_SCHEMA the data database.","title":"ARCHIVE_TABLE"},{"location":"settings/#archive_columns","text":"Default: [ { 'name': 'id', 'hidden': True }, { 'name': 'timestamp', 'label': 'Timestamp' }, { 'name': 'file', 'label': 'Filename', 'ucd': 'meta.file' }, { 'name': 'collection', 'hidden': True }, { 'name': 'path', 'hidden': True } ] Sets the additional columns for the archive in the table set by ARCHIVE_TABLE the data database.","title":"ARCHIVE_COLUMNS"},{"location":"settings/#daiquiriauthsettings","text":"","title":"daiquiri.auth.settings"},{"location":"settings/#auth_signup","text":"Default: False Designates if users can register for an account. If set to false, all users need to be created through the Django admin system.","title":"AUTH_SIGNUP"},{"location":"settings/#auth_workflow","text":"Default: None Sets the workflow for user registration. Options are None : Newly registered users can log in after registartion. 'activation' : Newly registered users need to be activated by a manager or admin. 'confirmation' : Newly registered users need to be confirmed by a manager before they are activated by an admin.","title":"AUTH_WORKFLOW"},{"location":"settings/#auth_detail_keys","text":"Default: [] Sets additional details to be asked from the users when registering. An example would be: AUTH_DETAIL_KEYS = [ { 'key': 'affiliation', 'label': 'Affiliation', 'data_type': 'text', 'required': True, 'options': [] }, ] where: key is the internal identifier, label the text shown in the interface, datatype the type of the detail which affects the widget to be used ( 'text' , 'textarea' , 'select' , 'radio' , 'multiselect' , or 'checkbox' ), required whether this detail is required or not, and options a list of options for select, radio or checkboxes widgets of the form [{'id': id, 'label': label}, ...] .","title":"AUTH_DETAIL_KEYS"},{"location":"settings/#auth_terms_of_use","text":"Default: False Designates whether terms of use are displayed on the signup page and need to be accepted to register. The text of to displayed needs to be configured in a template account/terms_of_use.html .","title":"AUTH_TERMS_OF_USE"},{"location":"settings/#daiquiricutoutsettings","text":"","title":"daiquiri.cutout.settings"},{"location":"settings/#conesearch_adapter","text":"Default: 'daiquiri.conesearch.adapter.SimpleConeSearchAdapter' Sets the adapter class to be used by the cone search api. The adapter class encapsulated all operations creating a cone search votable output from the api request. Custom adapter need to enherit from daiquiri.conesearch.adapter.BaseConeSearchAdapter .","title":"CONESEARCH_ADAPTER"},{"location":"settings/#conesearch_anonymous","text":"Default: False Designates if cone searches can be done by by anonymus users.","title":"CONESEARCH_ANONYMOUS"},{"location":"settings/#daiquiricutoutsettings_1","text":"","title":"daiquiri.cutout.settings"},{"location":"settings/#cutout_adapter","text":"Default: 'daiquiri.cutout.adapter.SimpleCutOutAdapter' Sets the adapter class to be used by the cutout api. The adapter class encapsulated all operations creating a cut out from the api request. Custom adapter need to enherit from daiquiri.cutout.adapter.BaseCutOutAdapter .","title":"CUTOUT_ADAPTER"},{"location":"settings/#cutout_anonymous","text":"Default: False Designates if the cutout interface can be accessed by anonymus users.","title":"CUTOUT_ANONYMOUS"},{"location":"settings/#daiquirifilessettings","text":"","title":"daiquiri.files.settings"},{"location":"settings/#files_base_path","text":"Default: os.path.join(BASE_DIR, 'files') Sets the absolute base path of the files served by the files module in the local file system. Should be set in .env .","title":"FILES_BASE_PATH"},{"location":"settings/#files_base_url","text":"Default: None Sets the absolute URL for this Daiquiri app to be prepended to file references when downloading query results. This is done for columns with the meta.ref;meta.file , meta.ref;meta.image or meta.ref;meta.note UCD. Should be set in .env .","title":"FILES_BASE_URL"},{"location":"settings/#daiquirimeetingssettings","text":"","title":"daiquiri.meetings.settings"},{"location":"settings/#meetings_contribution_types","text":"Default: [ ('talk', _('Talk')), ('poster', _('Poster')) ] Sets the types of contributions to be selected by partcipants when registering.","title":"MEETINGS_CONTRIBUTION_TYPES"},{"location":"settings/#meetings_payment_choices","text":"Default: [ ('cash', _('cash')), ('wire', _('wire transfer')), ] Sets the different payment choices to be selected by partcipants when registering.","title":"MEETINGS_PAYMENT_CHOICES"},{"location":"settings/#meetings_participant_detail_keys","text":"Default: [] Sets additional details to be asked from the participants when registering. An example would be: MEETINGS_PARTICIPANT_DETAIL_KEYS = [ { 'key': 'affiliation', 'label': 'Affiliation', 'data_type': 'text', 'required': True }, { 'key': 'dinner', 'label': 'Conference dinner', 'data_type': 'radio', 'required': True, 'options': [ {'id': 'yes', 'label': 'yes'}, {'id': 'no', 'label': 'no'} ] } ] where: key is the internal identifier, label the text shown in the interface, datatype the type of the detail which affects the widget to be used ( 'text' , 'textarea' , 'select' , 'radio' , 'multiselect' , or 'checkbox' ), required whether this detail is required or not, and options a list of options for select, radio or checkboxes widgets of the form [{'id': id, 'label': label}, ...] .","title":"MEETINGS_PARTICIPANT_DETAIL_KEYS"},{"location":"settings/#meetings_abstract_max_length","text":"Default: 2000 Sets the maximum lenght of an abstract.","title":"MEETINGS_ABSTRACT_MAX_LENGTH"},{"location":"settings/#daiquirimetadatasettings","text":"","title":"daiquiri.metadata.settings"},{"location":"settings/#metadata_column_permissions","text":"Default: False Designates if permissions can be assigned to individual columns (in addition to tables and schemas). This is an experimental feature.","title":"METADATA_COLUMN_PERMISSIONS"},{"location":"settings/#metadata_base_url","text":"Default: None Sets the absolute URL of the metadata module, e.g. http://example.com/metadata/. The URL is used to create links to the landing pages for schemas and tables in VOTables if a DOI is not set.","title":"METADATA_BASE_URL"},{"location":"settings/#daiquirioaisettings","text":"","title":"daiquiri.oai.settings"},{"location":"settings/#oai_schema","text":"Default: OAI_SCHEMA Sets the name of the schema for OAI records. If more than one Daiquiri application is using the same data database, they cannot use the same OAI_SCHEMA schema. This setting must be set in .env","title":"OAI_SCHEMA"},{"location":"settings/#oai_adapter","text":"Default: 'daiquiri.metadata.adapter.RegistryDoiMetadataOaiAdapter' Sets the adapter class to be used by the OAI-PMH api. The adapter class encapsulated all operations to set up and retrieve the OAI records. Custom adapter need to enherit from daiquiri.metadata.adapter.BaseOaiAdapter . Usually this will be done in the Daiquiri app, e.g. OAI_ADAPTER = 'app.adapter.OaiAdapter'","title":"OAI_ADAPTER"},{"location":"settings/#oai_page_size","text":"Default: 500 Number of records returned in a OAI-PMH request.","title":"OAI_PAGE_SIZE"},{"location":"settings/#daiquiriquerysettings","text":"","title":"daiquiri.query.settings"},{"location":"settings/#query_anonymous","text":"Default: False Designates if the query interface can be accessed by anonymus users. The permissions on schemas and tables need to be configured using the metadata interface.","title":"QUERY_ANONYMOUS"},{"location":"settings/#query_user_schema_prefix","text":"Default: 'daiquiri_user_' Sets the prefix for user schemas in the data database. Each user has a private schema where the result table of successful queries are stored.","title":"QUERY_USER_SCHEMA_PREFIX"},{"location":"settings/#query_quota","text":"Default: { 'anonymous': '100Mb', 'user': '10000Mb', 'users': {}, 'groups': {} } Sets the maximum quota for tables in a user\u2019s personal schema. The quota need to be set for the anonymous user as well as regular loggen in users ( user ). Additionally, users or groups can be asigned individual quotas, e.g.: { 'anonymous': '100Mb', 'user': '10000Mb', 'users': { 'admin': '1000Gb' }, 'groups': { 'collab': '100Gb' } } If more than one quota applies, the maximum is used.","title":"QUERY_QUOTA"},{"location":"settings/#query_sync_timeout","text":"Default: 5 Sets the timeout for syncronous (TAP) queries in seconds.","title":"QUERY_SYNC_TIMEOUT"},{"location":"settings/#query_max_active_jobs","text":"Default: { 'anonymous': '1' } Sets the maximum of simultanous jobs for users. The setting work analog to \u2018QUERY_QUOTA\u2019. If more than one maximum applies, the maximum is used. If no maximum is given, like the default setting for logged users, no maximum is enforced.","title":"QUERY_MAX_ACTIVE_JOBS"},{"location":"settings/#query_queues","text":"Default: [ { 'key': 'default', 'label': 'Default', 'timeout': 10, 'priority': 1, 'access_level': 'PUBLIC', 'groups': [] } ] Set the different queue, which can be selected by the users. Each queue is represented by a dictionary where: key is the internal identifier, label is the text shown in the interface, timeout the maximum excecution time in seconds, priority is a integer number indicationg the priority in which jobs are executed, and access_level and groups the usual restiction on who can use this queue. Jobs in a queue with higher priority are selected first when a query worker becomes available.","title":"QUERY_QUEUES"},{"location":"settings/#query_languages","text":"Default: [ { 'key': 'adql', 'version': 2.0, 'label': 'ADQL', 'description': '', 'quote_char': '\"' } ] Sets the different query languages, which can be selected by the users. Each query language is represented by a dictionary where: key is the internal identifier, label is the text shown in the interface, description is additional information shown, e.g. in TopCat, and quote_char the character used by the database system to quote identifiers. Already implemented in Daiquiri are adql , postgresql , and mysql . Apart from ADQL, the query language must match the database system of the data database.","title":"QUERY_LANGUAGES"},{"location":"settings/#query_forms","text":"Default: [ { 'key': 'sql', 'label': 'SQL query', 'service': 'query/js/forms/sql.js', 'template': 'query/query_form_sql.html' } ] Sets the form available for the users in the query interface. Each form is represented by a dictionary where: key is the internal identifier, label is the text shown in the interface, service the path AngularJS service containing the client side logic, and template the path to the Django template with the markup for the form. Included in Daiquiri are sql and (simplyfied) cone and box services.","title":"QUERY_FORMS"},{"location":"settings/#query_dropdowns","text":"Default: [ { 'key': 'simbad', 'service': 'query/js/dropdowns/simbad.js', 'template': 'query/query_dropdown_simbad.html', 'options': { 'url': 'http://simbad.u-strasbg.fr/simbad/sim-id' } }, { 'key': 'vizier', 'service': 'query/js/dropdowns/vizier.js', 'template': 'query/query_dropdown_vizier.html', 'options': { 'url': 'http://vizier.u-strasbg.fr/viz-bin/votable', 'catalogs': ['I/322A', 'I/259'] } } ] Sets the additional drop down menus above the SQL query interface available for the users. Each drop down is represented by a dictionary where: key is the internal identifier, service the path AngularJS service containing the client side logic, template the path to the Django template with the markup, and options additional options specific to the drop down. Included in Daiquiri are simbad and vizier services.","title":"QUERY_DROPDOWNS"},{"location":"settings/#query_download_dir","text":"Default: os.path.join(BASE_DIR, 'download') Sets the absolute base path of the download files served by the query module in the local file system.","title":"QUERY_DOWNLOAD_DIR"},{"location":"settings/#query_default_download_format","text":"Default: 'votable' Sets the default download format.","title":"QUERY_DEFAULT_DOWNLOAD_FORMAT"},{"location":"settings/#query_download_formats","text":"Default: [ { 'key': 'votable', 'extension': 'xml', 'content_type': 'application/xml', 'label': 'IVOA VOTable XML file - TABLEDATA serialization', 'help': 'A XML file using the IVOA VOTable format. Use this option if you intend to use VO compatible software to further process the data.' }, { 'key': 'csv', 'extension': 'csv', 'content_type': 'text/csv', 'label': 'Comma separated Values', 'help': 'A text file with a line for each row of the table. The fields are delimited by a comma and quoted by double quotes. Use this option for a later import into a spreadsheed application or a custom script. Use this option if you are unsure what to use.' }, { 'key': 'fits', 'extension': 'fits', 'content_type': 'application/fits', 'label': 'FITS', 'help': 'Flexible Image Transport System (FITS) file format.' } ] Sets the available default download formats. Each format is represented by a dictionary where: key is the internal identifier, extension the file extension, content_type the content type, label the text shown in the interface, and help a more verbose help text for the format.","title":"QUERY_DOWNLOAD_FORMATS"},{"location":"settings/#query_upload","text":"Default: True Enables the upload functionality in the query interface. QUERY_UPLOAD_LIMIT Default: { 'anonymous': '10Mb', 'user': '100Mb', 'users': {}, 'groups': {} } Sets the maximum quota for uploads by a user. The quota need to be set for the anonymous user as well as regular loggen in users ( user ). Additionally, users or groups can be asigned individual quotas, much like with QUERY_QUOTA .","title":"QUERY_UPLOAD"},{"location":"settings/#daiquiriservesettings","text":"","title":"daiquiri.serve.settings"},{"location":"settings/#serve_download_dir","text":"Default: os.path.join(BASE_DIR, 'download') Sets the absolute base path of the download files served by the serve module in the local file system.","title":"SERVE_DOWNLOAD_DIR"},{"location":"settings/#serve_resolver","text":"Default: None Sets the a resolver class to handle references in tables served by the serve module.","title":"SERVE_RESOLVER"},{"location":"settings/#daiquiristatssettings","text":"","title":"daiquiri.stats.settings"},{"location":"settings/#stats_resource_types","text":"Default: [ { 'key': 'ARCHIVE_DOWNLOAD', 'label': 'Archive downloads' }, { 'key': 'CONESEARCH', 'label': 'Performed cone searches' }, { 'key': 'CUTOUT', 'label': 'Performed cutouts' }, { 'key': 'FILE', 'label': 'File downloads' }, { 'key': 'QUERY', 'label': 'Queries' } ] Sets the aggegated stats shown in the stats management overview.","title":"STATS_RESOURCE_TYPES"},{"location":"settings/#daiquiritapsettings","text":"","title":"daiquiri.tap.settings"},{"location":"settings/#tap_schema","text":"Default: 'TAP_SCHEMA' Sets the name of the TAP schema. If more than one Daiquiri application is using the same data database, they cannot use the same TAP schema. Therefore the schema name TAP_SCHEMA is replaced before queries are submitted. This setting must be set in .env","title":"TAP_SCHEMA"},{"location":"settings/#tap_upload","text":"Default: 'TAP_UPLOAD' Sets the name of the schema for TAP uploads. If more than one Daiquiri application is using the same data database, they cannot use the same TAP_UPLOAD schema. Therefore the schema name TAP_UPLOAD is replaced before queries are submitted. This setting must be set in .env","title":"TAP_UPLOAD"},{"location":"settings/#daiquiriuwssettings","text":"","title":"daiquiri.uws.settings"},{"location":"settings/#uws_resources","text":"Default: [] Configures UWS services (in addition to the TAP module). E.g.: { 'prefix': r'query', 'viewset': 'daiquiri.query.viewsets.UWSQueryJobViewSet', 'base_name': 'uws_query' } where: prefix is part of the base URL of the service (e.g. http://example.com/usw/query), viewset is the ViewSet class handling the requests (neets to enherit from daiquiri.jobs.viewsets.AsyncJobViewSet ), and base_name a basename needed for the integration in the Django REST framework.","title":"UWS_RESOURCES"},{"location":"settings/#daiquiriwordpresssettings","text":"","title":"daiquiri.wordpress.settings"},{"location":"settings/#wordpress_path","text":"Default: '/opt/wordpress' Sets the location of the WordPress installation on the local file system.","title":"WORDPRESS_PATH"},{"location":"settings/#wordpress_ssh","text":"Default: None Sets the destination for a SSH connection to use with wp-cli . Use this setting if WordPress is not installed on the same host as Daiquiri. The local wp-cli will then connect to the remote system using ssh. An example would be: WORDPRESS_SSH=example.com:/opt/daiquiri This option overided WORDPRESS_PATH .","title":"WORDPRESS_SSH"},{"location":"settings/#wordpress_cli","text":"Default: '/opt/wp-cli/wp' Sets the location of the wp-cli script on the local file system.","title":"WORDPRESS_CLI"},{"location":"settings/#wordpress_url","text":"Default: '/cms/' Sets the base url of the WordPress instance.","title":"WORDPRESS_URL"}]}