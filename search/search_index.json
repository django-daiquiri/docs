{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Daiquiri Daiquiri is a framework for the publication of scientific databases. Home page https://django-daiquiri.github.io GitHub organization https://github.com/django-daiquiri PyPI releases https://pypi.org/project/django-daiquiri Introduction Today, the publication of research data plays an important role in astronomy and astrophysics. On the one hand, dedicated surveys like SDSS and RAVE, data intensive instruments like LOFAR, or massive simulations like Millennium and MultiDark are initially planned to release their data for the community. On the other hand, more traditionally oriented research projects strive to publish their data as a key requirement demanded by the funding agencies. The common approach is to publish this data via dedicated web sites. This includes rather simple HTML forms as well as complex query systems such as SDSS-CAS. Most of these web sites are tailor made for the particular case and are therefore not easily transferable to future projects. At Leibniz-Institute for Astrophysics Potsdam (AIP) , we gained experience with both the maintenance and the development of such applications. It became, however, apparent that already the current plethora of applications constitutes a major challenge for maintenance expenses and scalability. In order to address these issues, we developed the Daiquiri framework , which is particularly designed to allow for different highly customizable web applications based on a common easily maintainable code base. Features Daiquiri enables collaboration and institutions to create customized websites, comprising of the following features: An interactive Query interface enabling users to perform SQL/ADQL queries against catalog databases. The queries are analyzed using the queryparser and permissions are checked depending on user accounts and groups. Asynchronous database queries, which can take minutes or even hours. Download of the query results in different formats and visualization of the data. A programmatic interface to the database implementing the IVOA TAP protocol. A cone search API based on the IVOA Simple Cone Search recommendation. An integration into to IVOA registry of registry to make the VO endpoints available in applications like, e.g. topcat . A metadata management backend containing information about the database schemas and tables including DOI and UCD. The download of files connected to the database tables, including access restrictions. An OAI-PMH2 endpoint to make the metadata stored in the system available to harvesters. A cut-out API for multi-dimensional data (e.g. data cubes). A sophisticated user management system with customizable registration and confirmation workflows. A contact form connected to the management backend. A meeting module to organize workshops and smaller conferences. An integrated WordPress content management system for documentation and/or the presentation of the project. Requirements Daiquiri is based on Django and is written in Python. The following requirements are mandatory: Python >=3.9 PostgreSQL >=13 (MariaDB >=10.1 or MySQL >=5.6 not actively supported anymore) RabbitMQ >=3.8 (for asyncronous tasks like the query queue) For demonstration, development or testing purposes, Daiquiri can be installed on Linux, macOS, or even Windows. If you, however, intent to set up a production environment, serving Daiquiri over a Network or the Internet, we strongly suggest that you use a recent Linux distribution, namely: Debian 12 Ubuntu 20.04 Usage Daiquiri is currently used on several sites hosted and maintained by the Leibniz-Institute for Astrophysics Potsdam (AIP) : Gaia@AIP Services APPLAUSE archives MUSE-Wide survey GREGOR project and archive CLUES \u2013 Constrained Local UniversE Simulations project CosmoSim database (legacy version) RAVE Survey (legacy version) License Daiquiri is Licensed unter the Apache License 2.0 . The full license text is part of the source code repository at github.com/django-daiquiri/daiquiri .","title":"Home"},{"location":"#daiquiri","text":"Daiquiri is a framework for the publication of scientific databases. Home page https://django-daiquiri.github.io GitHub organization https://github.com/django-daiquiri PyPI releases https://pypi.org/project/django-daiquiri","title":"Daiquiri"},{"location":"#introduction","text":"Today, the publication of research data plays an important role in astronomy and astrophysics. On the one hand, dedicated surveys like SDSS and RAVE, data intensive instruments like LOFAR, or massive simulations like Millennium and MultiDark are initially planned to release their data for the community. On the other hand, more traditionally oriented research projects strive to publish their data as a key requirement demanded by the funding agencies. The common approach is to publish this data via dedicated web sites. This includes rather simple HTML forms as well as complex query systems such as SDSS-CAS. Most of these web sites are tailor made for the particular case and are therefore not easily transferable to future projects. At Leibniz-Institute for Astrophysics Potsdam (AIP) , we gained experience with both the maintenance and the development of such applications. It became, however, apparent that already the current plethora of applications constitutes a major challenge for maintenance expenses and scalability. In order to address these issues, we developed the Daiquiri framework , which is particularly designed to allow for different highly customizable web applications based on a common easily maintainable code base.","title":"Introduction"},{"location":"#features","text":"Daiquiri enables collaboration and institutions to create customized websites, comprising of the following features: An interactive Query interface enabling users to perform SQL/ADQL queries against catalog databases. The queries are analyzed using the queryparser and permissions are checked depending on user accounts and groups. Asynchronous database queries, which can take minutes or even hours. Download of the query results in different formats and visualization of the data. A programmatic interface to the database implementing the IVOA TAP protocol. A cone search API based on the IVOA Simple Cone Search recommendation. An integration into to IVOA registry of registry to make the VO endpoints available in applications like, e.g. topcat . A metadata management backend containing information about the database schemas and tables including DOI and UCD. The download of files connected to the database tables, including access restrictions. An OAI-PMH2 endpoint to make the metadata stored in the system available to harvesters. A cut-out API for multi-dimensional data (e.g. data cubes). A sophisticated user management system with customizable registration and confirmation workflows. A contact form connected to the management backend. A meeting module to organize workshops and smaller conferences. An integrated WordPress content management system for documentation and/or the presentation of the project.","title":"Features"},{"location":"#requirements","text":"Daiquiri is based on Django and is written in Python. The following requirements are mandatory: Python >=3.9 PostgreSQL >=13 (MariaDB >=10.1 or MySQL >=5.6 not actively supported anymore) RabbitMQ >=3.8 (for asyncronous tasks like the query queue) For demonstration, development or testing purposes, Daiquiri can be installed on Linux, macOS, or even Windows. If you, however, intent to set up a production environment, serving Daiquiri over a Network or the Internet, we strongly suggest that you use a recent Linux distribution, namely: Debian 12 Ubuntu 20.04","title":"Requirements"},{"location":"#usage","text":"Daiquiri is currently used on several sites hosted and maintained by the Leibniz-Institute for Astrophysics Potsdam (AIP) : Gaia@AIP Services APPLAUSE archives MUSE-Wide survey GREGOR project and archive CLUES \u2013 Constrained Local UniversE Simulations project CosmoSim database (legacy version) RAVE Survey (legacy version)","title":"Usage"},{"location":"#license","text":"Daiquiri is Licensed unter the Apache License 2.0 . The full license text is part of the source code repository at github.com/django-daiquiri/daiquiri .","title":"License"},{"location":"administration/","text":"Administration Admin interface Daiquiri uses the Django Admin interfaca as an interface for admins to intereact with a particular Daiquiri site. Please refer to the Django documentation for a detailed guide. Here we summarize the most important options: Site configuration Daiquiri uses Django\u2019s sites framework . It is therefore necesary to configure the Domain name and the Display name of your Daiquiri installation. This can be done in the admin interface under SITE . Users and Groups The users and groups of your Daiquiri site can be managed under AUTHENTICATION AND AUTHORIZATION . You can create and update users and set their password directly, but most of the time this will be done by the users themselves using the account menu. The user created in the installation process can access all features of Daiquiri. In order to allow other users to access the management or the admin interface, they need to have the required permissions assigned to them. This can be done in two ways: through groups or using the superuser flag. Social accounts Using the django-allauth , social authentication using the OAuth2 protocol can be used with Daiquiri. For this 'allauth.socialaccount' and, e.g. for GitHub, 'allauth.socialaccount.providers.github' need to be added to INSTALLED_APPS in base.py . In addition, your app needs to be registered with the provider. The callback url needed for the registration is <site url>/account/<provider>/login/callback/ Once the credentials are obtained, you need to enter them in the admin interface under SOCIAL ACCOUNTS. Click on Add social application and: Select the corresponding provider Enter a Name of your choice Enter the Client id (or App ID) and the Secret key (or Client secret, Client key, App Secret) Add your site to the chosen sites. Click save. Command line tools In addition the web interface, Daiquiri provides several commands to inter, which can be Setup groups The permission system of Daiquiri utilizes a set of groups to manage access to the management interfaces and the WordPress integration. These groups can be created using: python manage.py setup_groups The groups creates are: contact_manager meetings_manager metadata_manager stats_manager query_manager user_manager Setup TAP_SCHEMA In order to setup the metadata for the TAP_SCHEMA run the following command (in your virtual environment): python manage.py setup_tap_metadata After this, /metadata/management/ should show a schema entry for the tap_schema . Rebuild TAP_SCHEMA The metadata is automatically synced between the metadata and the the TAP_SCHEMA. In order to rebuild the TAP_SCHEMA from scratch, you can use: python manage.py rebuild_tap_schema Rebuild DATALINK_TABLE The global datalink table is partly used for metadata management. DOI and related identifier entries for public schemas and tables with a doi field are automatically generated. Additionally, all declared extra datalink tables (see DATALINK_TABLES setting variable) will be gathered and ingested into the global datalink table. The global datalink table is in the TAP_SCHEMA . It is publically available and can be queried via TAP. The extra datalink table should stay PRIVATE . To resync the global datalink table with the metadata, and new extra datalink tables, you can use: python manage.py rebuild_datalink_table Rebuild OAI Schema Similar to the TAP_SCHEMA, the records for the OAI-PMH interface are located in a seperate schema, whithin the scientific database. In order to create the oai_schema from scratch, use: python manage.py rebuild_oai_schema Be aware that the OAI schema requires an up-to-date datalink table. So the datalink app should be activated, the global datalink table should exists: setup_tap_schema , and up-to-date: rebuild_datalink_table . Dump Fixtures # extract examples python manage.py dumpdata daiquiri_query.example > examples.json # extract files python manage.py dumpdata daiquiri_files.directory > directories.json # extract functions python manage.py dumpdata daiquiri_metadata.function > functions.json # extract groups python manage.py dumpdata auth.group > groups.json # extract users python manage.py dumpdata auth.user daiquiri_auth.profile account.emailaddress socialaccount > users.json # extract announcement messages python manage.py dumpdata daiquiri_contact.annoucementmessage > announcement_messages.json Load Fixtures # load examples python manage.py loaddata examples.json # load files python manage.py loaddata directories.json # load functions python manage.py loaddata functions.json # load groups python manage.py loaddata groups.json # load users python manage.py loaddata users.json # load announcement messages python manage.py loaddata announcement_messages.json Setup the scientific database For helping the administrator in properly creating the scientific database, you can use: python manage.py sqlcreate Note: on the contrary to its name sqlcreate do not create anything, it just prints the SQL statement to properly create the science tables. For the extra datalink tables, you can use: python manage.py sqlcreate --datalink=<extra-datalink-tablename> Notes on datalink The extra datalink tables have four purposes: improving the metadata with non-standard entries creating relation between objects and groups simplifying the discovery and access of files declaring cross-table information for given object Improving the metadata For the tables and schemas with a DOI, the command rebuild_datalink_table creates three datalink entries for each table/schema relating their names to their documentation, related identifier and the DOI url. However, not only tables and schema may have DOI, also objects or groups of objects may also have DOIs. In this case, it is possible to use the extra datalink tables to create the relation between objects and their DOIs. The extra datalink tables should be named like: <release_schema>.<object_category>_doi . The table should be filled as follow: the ID should contain the unique string identifying the object in the database: <object_id> the access_url is for the <doi_url> the semantics is always #doi in this datalink table. After executing the commands rebuild_datalink_table and rebuild_oai_schema , the objects will have entries in both, the global datalink table and the oai schema. The first ones can be queried via TAP_SCHEMA.datalink and the second via the OAI-PMH api. The following table lists additional datalink entries that can be used for every objects to enrich the metadata for OAI-PMH semantic OAI-PMH entry #this <relatedIdentifier relatedIdentifierType=\"URL\" relationType=\"IsDescribedBy\">access_url</relatedIdentifier> #preview <alternateIdentifier alternateIdentifierType=\"DOI Landing Page\">access_url</alternateIdentifier> #preview-image <relatedIdentifier relatedIdentifierType=\"URL\" relationType=\"IsSupplementedBy\">access_url</relatedIdentifier> #detached-header <relatedIdentifier relatedIdentifierType=\"URL\" relationType=\"IsSupplementedBy\">access_url</relatedIdentifier> #documentation <relatedIdentifier relatedIdentifierType=\"URL\" relationType=\"IsDocumentedBy\">access_url</relatedIdentifier> #progenitor <relatedIdentifier relatedIdentifierType=\"URL\" relationType=\"IsDerivedFrom\">access_url</relatedIdentifier> #auxiliary <relatedIdentifier relatedIdentifierType=\"URL\" relationType=\"References\">access_url</relatedIdentifier> The examples for the use of the semantics are | semantic | Used for\u2026 | |------------------|-----------------------------------------------------------------------------------------------------------------| | #this | fits, hdf5, csv files, and resources holding the data | | #preview | viewers and doi-landing pages | | #preview-image | png, jpeg holding the represantation of the data | | #detached-header | fits header, e.g., from previous releases | | #documentation | related documentation pages | More info on semantics: https://www.ivoa.net/rdf/datalink/core In Daiquiri, it is possible to create additional custom semantics by using the settings variable DATALINK_CUSTOM_SEMANTICS . For instance, the daiquiri specific custom sematic #doi is defined as DATALINK_CUSTOM_SEMANTICS = { \"#doi\": \"The access_url points to the Digital Object Identifier (DOI) of the object.\", } Creating relation between object and groups Several objects may be part of a group of objects, i.e.: fields, observations, survey, etc. In order to create a discoverable link, it is possible to use the extra datalink tables. The extra datalink table should names like: <release_schema>.<group_category>_datalink . The table should be filled as follows: 1. ID : <group_name>/<group_id> 2. access_url : url pointing to the linked ressource 3. semantics : depends on the linked ressource This way after rebuild_datalink_table and rebuild_oai_schema the groups will have entries in both the global datalink table and the oai schema. Note that a OAI Set with the group name is automatically created in the OAI schema, if the ID is build like <group_name>/<group_id> . Simplifying file access Often, the objects are provided not only in a from of a database record but also as a downloadable file (.fits, .png, etc). This is the main use-case for the datalink protocol. The files can be linked with the corresponding database object using a separate datalink table. The extra datalink table should be named like: <release_schema>.<object_categoty>_files . The table should be filled as follow: the ID field should be filled with <object_id> the access_url should be filled with the downloadable url of the file the semantics should be filled with the relevant value, i.e.: https://www.ivoa.net/rdf/datalink/core/2022-01-27/datalink.html the content_type should be filled with the relevant value: i.e.: http://www.iana.org/assignments/media-types/media-types.xhtml the content_size should be filled with the size of the file in bytes. This way after rebuild_datalink_table and the object will have entries linking to the download links of related files in the global datalink table, queriable either via TAP_SCHEMA.datalink or the datalink protocol, e.g. /datalink/links?ID=<objects_id> . Declaring cross-tables information for given objects Usually it may be relevant to split the information on object over sevral tables. Especially if the object somehow differ from nature and do not hold information in all tables. Typically light sources in the sky may be either stellar objects, galaxies, etc. These objects share informations in a main table, but specific information are spearded over various annex tables. In this case it is usefull to provide in the main table flags to declare the existance of specific information in an annex table. Typically stellar_flag , galaxy_flag \u2026 these flags can be queried via TAP and convinienty helps the user to find his/her way through the database. However, this still requires a knowledge about the naming and the existance of these flags. This is not sufficient for blind discovery. In order to allow user to blindly discover further specific information in annex tables, the extra datalink tables can be used: The extra datalink table should named like: <release_schema>.<object_category>_annex The table should be filled as follow: the ID should be filled with the unique string identifying the object in the database: <object _id> the access_url should be filled with the <doi_url> of the annex table, or its datalink url the semantics field should be filled with #auxilliary This way after rebuild_datalink_table the object will have blindly discoverable auxilliary information, that can be queried via TAP. The name of the table where the information can be found is present in the access_url and the value to query is the ID value. Notes: for a large number of objects, this method must not be employed because the datalink table may become much to large and dynamic datalink feature (not yet implemented) should be used instead. Metadata trigerring features ucd meta.ref Declares a column to be a reference. In the results tap of the query, this column will be rendered as a link toward the custom resolver ( resolver.py ). The value of the column will be passed to the custom resolver to allow value specific rendering. meta.main Declares a column as MAIN. This metadata identify the given column as a major contribution to the information of the table, this will be used by various daiquiri services to present information: conesearch and default viewer. Conesearch The VO Conesearch service accepts to select either the entire tables dataset, a reduced sub-set, or just identifer and position information. The reduced sub-set is defined via the metadata meta.main . Default viewer In the default viewer, in case a table is provided as additional information in the datalink entries of a given object, a query on the columns marked as meta.main will be submitted. meta.id This declares a column to be the datalink ID of the table. In combination with meta.ref the column link will directly to the datalink viewer. meta.ref;meta.file This declares a column to be the path to a FILE, it will be rendered as an URL and redirects to a download. meta.ref;meta.image This declares a column to be the path to a PREVIEW, it will be rendered as an URL and redirects to a front-view of the image with a download button. datatype and arraysize supported types: char boolean short int long float double spoint (ADQL) supported array types: short int long float double boolean array of known dimension For array of known dimension the metadata should be: datatype: <type>[] arraysize: <size> array of unknown dimension For array of unknown dimension the metadata should be: datatype: <type>[] arraysize: None (null) Notes on Postgres array storage On postgres side array should be stored as ARRAY of type _<type> .","title":"Administration"},{"location":"administration/#administration","text":"","title":"Administration"},{"location":"administration/#admin-interface","text":"Daiquiri uses the Django Admin interfaca as an interface for admins to intereact with a particular Daiquiri site. Please refer to the Django documentation for a detailed guide. Here we summarize the most important options:","title":"Admin interface"},{"location":"administration/#site-configuration","text":"Daiquiri uses Django\u2019s sites framework . It is therefore necesary to configure the Domain name and the Display name of your Daiquiri installation. This can be done in the admin interface under SITE .","title":"Site configuration"},{"location":"administration/#users-and-groups","text":"The users and groups of your Daiquiri site can be managed under AUTHENTICATION AND AUTHORIZATION . You can create and update users and set their password directly, but most of the time this will be done by the users themselves using the account menu. The user created in the installation process can access all features of Daiquiri. In order to allow other users to access the management or the admin interface, they need to have the required permissions assigned to them. This can be done in two ways: through groups or using the superuser flag.","title":"Users and Groups"},{"location":"administration/#social-accounts","text":"Using the django-allauth , social authentication using the OAuth2 protocol can be used with Daiquiri. For this 'allauth.socialaccount' and, e.g. for GitHub, 'allauth.socialaccount.providers.github' need to be added to INSTALLED_APPS in base.py . In addition, your app needs to be registered with the provider. The callback url needed for the registration is <site url>/account/<provider>/login/callback/ Once the credentials are obtained, you need to enter them in the admin interface under SOCIAL ACCOUNTS. Click on Add social application and: Select the corresponding provider Enter a Name of your choice Enter the Client id (or App ID) and the Secret key (or Client secret, Client key, App Secret) Add your site to the chosen sites. Click save.","title":"Social accounts"},{"location":"administration/#command-line-tools","text":"In addition the web interface, Daiquiri provides several commands to inter, which can be","title":"Command line tools"},{"location":"administration/#setup-groups","text":"The permission system of Daiquiri utilizes a set of groups to manage access to the management interfaces and the WordPress integration. These groups can be created using: python manage.py setup_groups The groups creates are: contact_manager meetings_manager metadata_manager stats_manager query_manager user_manager","title":"Setup groups"},{"location":"administration/#setup-tap_schema","text":"In order to setup the metadata for the TAP_SCHEMA run the following command (in your virtual environment): python manage.py setup_tap_metadata After this, /metadata/management/ should show a schema entry for the tap_schema .","title":"Setup TAP_SCHEMA"},{"location":"administration/#rebuild-tap_schema","text":"The metadata is automatically synced between the metadata and the the TAP_SCHEMA. In order to rebuild the TAP_SCHEMA from scratch, you can use: python manage.py rebuild_tap_schema","title":"Rebuild TAP_SCHEMA"},{"location":"administration/#rebuild-datalink_table","text":"The global datalink table is partly used for metadata management. DOI and related identifier entries for public schemas and tables with a doi field are automatically generated. Additionally, all declared extra datalink tables (see DATALINK_TABLES setting variable) will be gathered and ingested into the global datalink table. The global datalink table is in the TAP_SCHEMA . It is publically available and can be queried via TAP. The extra datalink table should stay PRIVATE . To resync the global datalink table with the metadata, and new extra datalink tables, you can use: python manage.py rebuild_datalink_table","title":"Rebuild DATALINK_TABLE"},{"location":"administration/#rebuild-oai-schema","text":"Similar to the TAP_SCHEMA, the records for the OAI-PMH interface are located in a seperate schema, whithin the scientific database. In order to create the oai_schema from scratch, use: python manage.py rebuild_oai_schema Be aware that the OAI schema requires an up-to-date datalink table. So the datalink app should be activated, the global datalink table should exists: setup_tap_schema , and up-to-date: rebuild_datalink_table .","title":"Rebuild OAI Schema"},{"location":"administration/#dump-fixtures","text":"# extract examples python manage.py dumpdata daiquiri_query.example > examples.json # extract files python manage.py dumpdata daiquiri_files.directory > directories.json # extract functions python manage.py dumpdata daiquiri_metadata.function > functions.json # extract groups python manage.py dumpdata auth.group > groups.json # extract users python manage.py dumpdata auth.user daiquiri_auth.profile account.emailaddress socialaccount > users.json # extract announcement messages python manage.py dumpdata daiquiri_contact.annoucementmessage > announcement_messages.json","title":"Dump Fixtures"},{"location":"administration/#load-fixtures","text":"# load examples python manage.py loaddata examples.json # load files python manage.py loaddata directories.json # load functions python manage.py loaddata functions.json # load groups python manage.py loaddata groups.json # load users python manage.py loaddata users.json # load announcement messages python manage.py loaddata announcement_messages.json","title":"Load Fixtures"},{"location":"administration/#setup-the-scientific-database","text":"For helping the administrator in properly creating the scientific database, you can use: python manage.py sqlcreate Note: on the contrary to its name sqlcreate do not create anything, it just prints the SQL statement to properly create the science tables. For the extra datalink tables, you can use: python manage.py sqlcreate --datalink=<extra-datalink-tablename>","title":"Setup the scientific database"},{"location":"administration/#notes-on-datalink","text":"The extra datalink tables have four purposes: improving the metadata with non-standard entries creating relation between objects and groups simplifying the discovery and access of files declaring cross-table information for given object","title":"Notes on datalink"},{"location":"administration/#improving-the-metadata","text":"For the tables and schemas with a DOI, the command rebuild_datalink_table creates three datalink entries for each table/schema relating their names to their documentation, related identifier and the DOI url. However, not only tables and schema may have DOI, also objects or groups of objects may also have DOIs. In this case, it is possible to use the extra datalink tables to create the relation between objects and their DOIs. The extra datalink tables should be named like: <release_schema>.<object_category>_doi . The table should be filled as follow: the ID should contain the unique string identifying the object in the database: <object_id> the access_url is for the <doi_url> the semantics is always #doi in this datalink table. After executing the commands rebuild_datalink_table and rebuild_oai_schema , the objects will have entries in both, the global datalink table and the oai schema. The first ones can be queried via TAP_SCHEMA.datalink and the second via the OAI-PMH api. The following table lists additional datalink entries that can be used for every objects to enrich the metadata for OAI-PMH semantic OAI-PMH entry #this <relatedIdentifier relatedIdentifierType=\"URL\" relationType=\"IsDescribedBy\">access_url</relatedIdentifier> #preview <alternateIdentifier alternateIdentifierType=\"DOI Landing Page\">access_url</alternateIdentifier> #preview-image <relatedIdentifier relatedIdentifierType=\"URL\" relationType=\"IsSupplementedBy\">access_url</relatedIdentifier> #detached-header <relatedIdentifier relatedIdentifierType=\"URL\" relationType=\"IsSupplementedBy\">access_url</relatedIdentifier> #documentation <relatedIdentifier relatedIdentifierType=\"URL\" relationType=\"IsDocumentedBy\">access_url</relatedIdentifier> #progenitor <relatedIdentifier relatedIdentifierType=\"URL\" relationType=\"IsDerivedFrom\">access_url</relatedIdentifier> #auxiliary <relatedIdentifier relatedIdentifierType=\"URL\" relationType=\"References\">access_url</relatedIdentifier> The examples for the use of the semantics are | semantic | Used for\u2026 | |------------------|-----------------------------------------------------------------------------------------------------------------| | #this | fits, hdf5, csv files, and resources holding the data | | #preview | viewers and doi-landing pages | | #preview-image | png, jpeg holding the represantation of the data | | #detached-header | fits header, e.g., from previous releases | | #documentation | related documentation pages | More info on semantics: https://www.ivoa.net/rdf/datalink/core In Daiquiri, it is possible to create additional custom semantics by using the settings variable DATALINK_CUSTOM_SEMANTICS . For instance, the daiquiri specific custom sematic #doi is defined as DATALINK_CUSTOM_SEMANTICS = { \"#doi\": \"The access_url points to the Digital Object Identifier (DOI) of the object.\", }","title":"Improving the metadata"},{"location":"administration/#creating-relation-between-object-and-groups","text":"Several objects may be part of a group of objects, i.e.: fields, observations, survey, etc. In order to create a discoverable link, it is possible to use the extra datalink tables. The extra datalink table should names like: <release_schema>.<group_category>_datalink . The table should be filled as follows: 1. ID : <group_name>/<group_id> 2. access_url : url pointing to the linked ressource 3. semantics : depends on the linked ressource This way after rebuild_datalink_table and rebuild_oai_schema the groups will have entries in both the global datalink table and the oai schema. Note that a OAI Set with the group name is automatically created in the OAI schema, if the ID is build like <group_name>/<group_id> .","title":"Creating relation between object and groups"},{"location":"administration/#simplifying-file-access","text":"Often, the objects are provided not only in a from of a database record but also as a downloadable file (.fits, .png, etc). This is the main use-case for the datalink protocol. The files can be linked with the corresponding database object using a separate datalink table. The extra datalink table should be named like: <release_schema>.<object_categoty>_files . The table should be filled as follow: the ID field should be filled with <object_id> the access_url should be filled with the downloadable url of the file the semantics should be filled with the relevant value, i.e.: https://www.ivoa.net/rdf/datalink/core/2022-01-27/datalink.html the content_type should be filled with the relevant value: i.e.: http://www.iana.org/assignments/media-types/media-types.xhtml the content_size should be filled with the size of the file in bytes. This way after rebuild_datalink_table and the object will have entries linking to the download links of related files in the global datalink table, queriable either via TAP_SCHEMA.datalink or the datalink protocol, e.g. /datalink/links?ID=<objects_id> .","title":"Simplifying file access"},{"location":"administration/#declaring-cross-tables-information-for-given-objects","text":"Usually it may be relevant to split the information on object over sevral tables. Especially if the object somehow differ from nature and do not hold information in all tables. Typically light sources in the sky may be either stellar objects, galaxies, etc. These objects share informations in a main table, but specific information are spearded over various annex tables. In this case it is usefull to provide in the main table flags to declare the existance of specific information in an annex table. Typically stellar_flag , galaxy_flag \u2026 these flags can be queried via TAP and convinienty helps the user to find his/her way through the database. However, this still requires a knowledge about the naming and the existance of these flags. This is not sufficient for blind discovery. In order to allow user to blindly discover further specific information in annex tables, the extra datalink tables can be used: The extra datalink table should named like: <release_schema>.<object_category>_annex The table should be filled as follow: the ID should be filled with the unique string identifying the object in the database: <object _id> the access_url should be filled with the <doi_url> of the annex table, or its datalink url the semantics field should be filled with #auxilliary This way after rebuild_datalink_table the object will have blindly discoverable auxilliary information, that can be queried via TAP. The name of the table where the information can be found is present in the access_url and the value to query is the ID value. Notes: for a large number of objects, this method must not be employed because the datalink table may become much to large and dynamic datalink feature (not yet implemented) should be used instead.","title":"Declaring cross-tables information for given objects"},{"location":"administration/#metadata-trigerring-features","text":"","title":"Metadata trigerring features"},{"location":"administration/#ucd","text":"","title":"ucd"},{"location":"administration/#metaref","text":"Declares a column to be a reference. In the results tap of the query, this column will be rendered as a link toward the custom resolver ( resolver.py ). The value of the column will be passed to the custom resolver to allow value specific rendering.","title":"meta.ref"},{"location":"administration/#metamain","text":"Declares a column as MAIN. This metadata identify the given column as a major contribution to the information of the table, this will be used by various daiquiri services to present information: conesearch and default viewer.","title":"meta.main"},{"location":"administration/#conesearch","text":"The VO Conesearch service accepts to select either the entire tables dataset, a reduced sub-set, or just identifer and position information. The reduced sub-set is defined via the metadata meta.main .","title":"Conesearch"},{"location":"administration/#default-viewer","text":"In the default viewer, in case a table is provided as additional information in the datalink entries of a given object, a query on the columns marked as meta.main will be submitted.","title":"Default viewer"},{"location":"administration/#metaid","text":"This declares a column to be the datalink ID of the table. In combination with meta.ref the column link will directly to the datalink viewer.","title":"meta.id"},{"location":"administration/#metarefmetafile","text":"This declares a column to be the path to a FILE, it will be rendered as an URL and redirects to a download.","title":"meta.ref;meta.file"},{"location":"administration/#metarefmetaimage","text":"This declares a column to be the path to a PREVIEW, it will be rendered as an URL and redirects to a front-view of the image with a download button.","title":"meta.ref;meta.image"},{"location":"administration/#datatype-and-arraysize","text":"supported types: char boolean short int long float double spoint (ADQL) supported array types: short int long float double boolean","title":"datatype and arraysize"},{"location":"administration/#array-of-known-dimension","text":"For array of known dimension the metadata should be: datatype: <type>[] arraysize: <size>","title":"array of known dimension"},{"location":"administration/#array-of-unknown-dimension","text":"For array of unknown dimension the metadata should be: datatype: <type>[] arraysize: None (null)","title":"array of unknown dimension"},{"location":"administration/#notes-on-postgres-array-storage","text":"On postgres side array should be stored as ARRAY of type _<type> .","title":"Notes on Postgres array storage"},{"location":"advanced/","text":"Advanced features Apache2 and mod_wsgi This is an alternative deployment without the need of systemd scripts for the web application. Any asyncronous workers, however, would still need these systemd scripts. The first thing, you have to do, is to uncomment: from dotenv import load_dotenv load_dotenv() in config/wsgi.py in your app . Install the Apache server and mod_wsgi on Debian or Ubuntu using: sudo apt install apache2 libapache2-mod-wsgi-py3 On CentOS 7 you need to enable the [IUS repository] first. Then install using: sudo yum install httpd python35u-mod_wsgi Then, edit the virtual host configuration: # in /etc/httpd/sites-available/default on Debian/Ubuntu # in /etc/httpd/conf.d/vhost.conf on RHEL/CentOS <VirtualHost *:80> ... WSGIDaemonProcess daiquiri user=daiquiri group=daiquiri \\ home=/srv/daiquiri/app python-home=/srv/daiquiri/app/env WSGIProcessGroup daiquiri WSGIScriptAlias / /srv/daiquiri/app/config/wsgi.py process-group=daiquiri WSGIPassAuthorization On Alias /static /srv/daiquiri/app/static_root/ <Directory /srv/daiquiri/app/static_root/> Require all granted </Directory> <Directory /srv/daiquiri/app/config/> <Files wsgi.py> Require all granted </Files> </Directory> </VirtualHost> Start the Apache server: # on Debian/Ubuntu sudo systemctl start apache2 sudo systemctl enable apache2 # on RHEL/CentOS sudo systemctl start httpd sudo systemctl enable httpd Your Daiquiri app should now be available on the configured virtual host, and the deployment can be continued as usual. Wagtail integration Since Wagtail is a Django-base CMS, it can be used together with Daiquiri easily. The main steps are explained in the Wagtail documentation . Here we assume that the customization to daiquiri are located in a Django app called daiquiri_app in your daiquiri-app directory. The file layout should be like this: \u251c\u2500\u2500 config \u251c\u2500\u2500 daiquiri_app \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 migrations \u2502 \u251c\u2500\u2500 models.py \u2502 \u251c\u2500\u2500 static \u2502 \u2514\u2500\u2500 templates \u251c\u2500\u2500 manage.py \u251c\u2500\u2500 media_root \u251c\u2500\u2500 static_root \u2514\u2500\u2500 vendor To enable Wagtail, add the following blocks to config/settings/base.py : from . import MIDDLEWARE ... INSTALLED_APPS = DJANGO_APPS + [ 'daiquiri_app', ... 'wagtail.contrib.forms', 'wagtail.contrib.redirects', 'wagtail.embeds', 'wagtail.sites', 'wagtail.users', 'wagtail.snippets', 'wagtail.documents', 'wagtail.images', 'wagtail.search', 'wagtail.admin', 'wagtail.core', 'modelcluster', 'taggit', ] + ADDITIONAL_APPS ... MIDDLEWARE += [ 'wagtail.contrib.redirects.middleware.RedirectMiddleware' ] This adds the Wagtail apps and a Wagtail-specific middleware. In config/urls.py add: from django.conf.urls.static import static ... from wagtail.admin import urls as wagtailadmin_urls from wagtail.core import urls as wagtail_urls urlpatterns = [ ... path('wagtail/', include(wagtailadmin_urls)), path('cms/', include(wagtail_urls)), ] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) if settings.DEBUG: urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) This adds the Wagtail backend at /wagtail/ and the content at /cms/ . You can also use: path('', include(wagtail_urls)), to create the home page with Wagtail as well. In this case, it needs to be the last entry, since otherwise it would override all other urls. After this Wagtail pages can be created as explained in the Wagtail documentation, starting here . In our example the page models would reside in daiquiri_app/models.py and the corresponding templates in daiquiri_app/templates/daiquiri_app . Initially, Wagtail creates a home page model without content, which of little use. The first step is usually to remove this Page and Site and create a new Site with a different HomePage model. This can be done automatically with the following data migration (e.g. for the app daiquiri_app ). # -*- coding: utf-8 -*- from django.db import migrations def data_migration(apps, schema_editor): ContentType = apps.get_model('contenttypes.ContentType') Page = apps.get_model('wagtailcore.Page') Site = apps.get_model('wagtailcore.Site') HomePage = apps.get_model('daiquiri_app.HomePage') Page.objects.get(slug='home').delete() # Create content type for homepage model content_type, created = ContentType.objects.get_or_create(model='homepage', app_label='daiquiri_app') # Create a new homepage homepage = HomePage.objects.create(title='CosmoSim', slug='home', content_type=content_type, path='00010001', depth=2, numchild=0, url_path='/', locale_id=1) # Create a site with the new homepage set as the root Site.objects.create(hostname='localhost', root_page=homepage, is_default_site=True) class Migration(migrations.Migration): dependencies = [ ('wagtailcore', '0002_initial_data'), ('daiquiri_app', '0001_initial'), ] operations = [ migrations.RunPython(data_migration), ] Double reverse proxy setup When running Daiquiri behind two reverse proxy servers, one as generic HTTP proxy as entrypoint to the local network and one to combine Gunicorn and Static assets on one application server, the follow setup can be used: Internet -> HTTP proxy (192.168.0.10) -> Application server (192.168.0.20) -> Gunicorn -> Static assets The virtual host configuration on the HTTP Proxy looks like this: <VirtualHost *:443> ... ProxyPass / http://app.local/ ProxyPassReverse / app.local/ <Location /> RequestHeader set X-Forwarded-Proto 'https' env=HTTPS </Location> </VirtualHost> On the application server the virtual host configuration is this: <VirtualHost *:80> ... SSLEngine on SSLCertificateFile ... SSLCertificateKeyFile ... SSLCACertificateFile ... SSLProtocol All -SSLv2 -SSLv3 SSLCipherSuite 'EDH+CAMELLIA:EDH+aRSA:EECDH+aRSA+AESGCM:EECDH+aRSA+SHA384:\\ EECDH+aRSA+SHA256:EECDH:+CAMELLIA256:+AES256:+CAMELLIA128:+AES128:\\ +SSLv3:!aNULL:!eNULL:!LOW:!3DES:!MD5:!EXP:!PSK:!DSS:!RC4:!SEED:\\ !ECDSA:CAMELLIA256-SHA:AES256-SHA:CAMELLIA128-SHA:AES128-SHA' RemoteIPHeader X-Forwarded-For RemoteIPTrustedProxy 192.168.0.10/32 Alias /static/ /srv/daiquiri/app/static_root/ <Directory /srv/daiquiri/app/static_root/> Require all granted </Directory> Alias /cms/ /opt/wordpress/ <Directory /opt/wordpress/> AllowOverride all Require all granted </Directory> ProxyPass /static ! ProxyPass /cms ! ProxyPass / http://localhost:9000/ ProxyPassReverse / http://localhost:9000/ <Location /cms/wp-json/> Deny from all </Location> </VirtualHost> The RemoteIPHeader implies that the remoteip module for Apache is installed and enabled. Up to date TLS/SSL settings can be found on bettercrypto.org . Daiquiri client Daiquiri client is a is a python library meant to be used with the Daiquiri Framework. It provides a set of functions which can be used to use the API of a Daiquiri powered website inside a script. The nessesarry HTTP requests are abstracted in a transparent way. Daiquiri client can be installed using pip install --upgrade https://github.com/django-daiquiri/client A script for getting the emails of all users using Daiquiri Client could look like this: from daiquiri_client import Client client = Client(DAIQUIRI_URL, TOKEN) for profile in client.auth.get_profiles(): print(profile['user']['email']) where DAIQUIRI_URL is the url of the Daiquiri site and TOKEN is your API token, which can be obtained from the Daiquiri site at the URL /accounts/token/ . A commen use case for Daiquiri client is the update of the metadata of a database schema. For this, first add the schema manually using the metadate management and make sure Automatically discover tables and columns is checked. Then prepare a yaml file of the form: - name: daiquiri_data_obs title: Observational data description: Some observational data long_description: Some more information about the data. attribution: Please cite the following paper ... order: 1 license: CC0 doi: 10.1000/xyz123 published: 2020-01-01 updated: 2018-01-01 access_level: PUBLIC metadata_access_level: PUBLIC creators: - name: Anna Admin first_name: Anna last_name: Admin orcid: https://orcid.org/0000-0001-2345-6789 affiliations: \"Institute of applied Administration\\nInstitute of theoretical Managament\" - name: Manni Manager orcid: https://orcid.org/0000-0001-2345-6790 affiliations: Institute of theoretical Managament contributors: - name: Some computer guy tables: - name: stars title: Stars description: Some stars data order: 1 license: CC0 doi: 10.1000/xyz123/123 published: 2020-01-01 updated: 2018-01-01 access_level: PUBLIC metadata_access_level: PUBLIC creators: - name: Anna Admin first_name: Anna last_name: Admin orcid: https://orcid.org/0000-0001-2345-6789 affiliations: - Institute of applied Administration - Institute of theoretical Managament - name: Manni Manager orcid: https://orcid.org/0000-0001-2345-6790 affiliations: - Institute of theoretical Managament columns: - name: id ucd: meta.id;meta.main - name: ra ucd: pos.eq.ra;meta.main - name: dec ucd: pos.eq.dec;meta.main - name: parallax ucd: pos.parallax and a python script or notebook with the following content: import yaml from daiquiri_client import Client DAIQUIRI_URL = 'http://localhost:8000' TOKEN = 'a35b0eb94ef906648445c9214bed30265af1062d' with open('update_metadata.yml') as f: local_schemas = yaml.safe_load(f.read()) client = Client(DAIQUIRI_URL, TOKEN) for remote_schema in client.metadata.get_schemas(nested=True): for local_schema in local_schemas: if remote_schema['name'] == local_schema['name']: client.metadata.update_schema(remote_schema['id'], local_schema) for remote_table in remote_schema['tables']: for local_table in local_schema['tables']: if remote_table['name'] == local_table['name']: client.metadata.update_table(remote_table['id'], local_table) for remote_column in remote_table['columns']: for local_column in local_table['columns']: if remote_column['name'] == local_column['name']: client.metadata.update_column(remote_column['id'], local_column) And execute it in a virtual environment where daiquiri_client is installed.","title":"Advanced features"},{"location":"advanced/#advanced-features","text":"","title":"Advanced features"},{"location":"advanced/#apache2-and-mod_wsgi","text":"This is an alternative deployment without the need of systemd scripts for the web application. Any asyncronous workers, however, would still need these systemd scripts. The first thing, you have to do, is to uncomment: from dotenv import load_dotenv load_dotenv() in config/wsgi.py in your app . Install the Apache server and mod_wsgi on Debian or Ubuntu using: sudo apt install apache2 libapache2-mod-wsgi-py3 On CentOS 7 you need to enable the [IUS repository] first. Then install using: sudo yum install httpd python35u-mod_wsgi Then, edit the virtual host configuration: # in /etc/httpd/sites-available/default on Debian/Ubuntu # in /etc/httpd/conf.d/vhost.conf on RHEL/CentOS <VirtualHost *:80> ... WSGIDaemonProcess daiquiri user=daiquiri group=daiquiri \\ home=/srv/daiquiri/app python-home=/srv/daiquiri/app/env WSGIProcessGroup daiquiri WSGIScriptAlias / /srv/daiquiri/app/config/wsgi.py process-group=daiquiri WSGIPassAuthorization On Alias /static /srv/daiquiri/app/static_root/ <Directory /srv/daiquiri/app/static_root/> Require all granted </Directory> <Directory /srv/daiquiri/app/config/> <Files wsgi.py> Require all granted </Files> </Directory> </VirtualHost> Start the Apache server: # on Debian/Ubuntu sudo systemctl start apache2 sudo systemctl enable apache2 # on RHEL/CentOS sudo systemctl start httpd sudo systemctl enable httpd Your Daiquiri app should now be available on the configured virtual host, and the deployment can be continued as usual.","title":"Apache2 and mod_wsgi"},{"location":"advanced/#wagtail-integration","text":"Since Wagtail is a Django-base CMS, it can be used together with Daiquiri easily. The main steps are explained in the Wagtail documentation . Here we assume that the customization to daiquiri are located in a Django app called daiquiri_app in your daiquiri-app directory. The file layout should be like this: \u251c\u2500\u2500 config \u251c\u2500\u2500 daiquiri_app \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 migrations \u2502 \u251c\u2500\u2500 models.py \u2502 \u251c\u2500\u2500 static \u2502 \u2514\u2500\u2500 templates \u251c\u2500\u2500 manage.py \u251c\u2500\u2500 media_root \u251c\u2500\u2500 static_root \u2514\u2500\u2500 vendor To enable Wagtail, add the following blocks to config/settings/base.py : from . import MIDDLEWARE ... INSTALLED_APPS = DJANGO_APPS + [ 'daiquiri_app', ... 'wagtail.contrib.forms', 'wagtail.contrib.redirects', 'wagtail.embeds', 'wagtail.sites', 'wagtail.users', 'wagtail.snippets', 'wagtail.documents', 'wagtail.images', 'wagtail.search', 'wagtail.admin', 'wagtail.core', 'modelcluster', 'taggit', ] + ADDITIONAL_APPS ... MIDDLEWARE += [ 'wagtail.contrib.redirects.middleware.RedirectMiddleware' ] This adds the Wagtail apps and a Wagtail-specific middleware. In config/urls.py add: from django.conf.urls.static import static ... from wagtail.admin import urls as wagtailadmin_urls from wagtail.core import urls as wagtail_urls urlpatterns = [ ... path('wagtail/', include(wagtailadmin_urls)), path('cms/', include(wagtail_urls)), ] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) if settings.DEBUG: urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) This adds the Wagtail backend at /wagtail/ and the content at /cms/ . You can also use: path('', include(wagtail_urls)), to create the home page with Wagtail as well. In this case, it needs to be the last entry, since otherwise it would override all other urls. After this Wagtail pages can be created as explained in the Wagtail documentation, starting here . In our example the page models would reside in daiquiri_app/models.py and the corresponding templates in daiquiri_app/templates/daiquiri_app . Initially, Wagtail creates a home page model without content, which of little use. The first step is usually to remove this Page and Site and create a new Site with a different HomePage model. This can be done automatically with the following data migration (e.g. for the app daiquiri_app ). # -*- coding: utf-8 -*- from django.db import migrations def data_migration(apps, schema_editor): ContentType = apps.get_model('contenttypes.ContentType') Page = apps.get_model('wagtailcore.Page') Site = apps.get_model('wagtailcore.Site') HomePage = apps.get_model('daiquiri_app.HomePage') Page.objects.get(slug='home').delete() # Create content type for homepage model content_type, created = ContentType.objects.get_or_create(model='homepage', app_label='daiquiri_app') # Create a new homepage homepage = HomePage.objects.create(title='CosmoSim', slug='home', content_type=content_type, path='00010001', depth=2, numchild=0, url_path='/', locale_id=1) # Create a site with the new homepage set as the root Site.objects.create(hostname='localhost', root_page=homepage, is_default_site=True) class Migration(migrations.Migration): dependencies = [ ('wagtailcore', '0002_initial_data'), ('daiquiri_app', '0001_initial'), ] operations = [ migrations.RunPython(data_migration), ]","title":"Wagtail integration"},{"location":"advanced/#double-reverse-proxy-setup","text":"When running Daiquiri behind two reverse proxy servers, one as generic HTTP proxy as entrypoint to the local network and one to combine Gunicorn and Static assets on one application server, the follow setup can be used: Internet -> HTTP proxy (192.168.0.10) -> Application server (192.168.0.20) -> Gunicorn -> Static assets The virtual host configuration on the HTTP Proxy looks like this: <VirtualHost *:443> ... ProxyPass / http://app.local/ ProxyPassReverse / app.local/ <Location /> RequestHeader set X-Forwarded-Proto 'https' env=HTTPS </Location> </VirtualHost> On the application server the virtual host configuration is this: <VirtualHost *:80> ... SSLEngine on SSLCertificateFile ... SSLCertificateKeyFile ... SSLCACertificateFile ... SSLProtocol All -SSLv2 -SSLv3 SSLCipherSuite 'EDH+CAMELLIA:EDH+aRSA:EECDH+aRSA+AESGCM:EECDH+aRSA+SHA384:\\ EECDH+aRSA+SHA256:EECDH:+CAMELLIA256:+AES256:+CAMELLIA128:+AES128:\\ +SSLv3:!aNULL:!eNULL:!LOW:!3DES:!MD5:!EXP:!PSK:!DSS:!RC4:!SEED:\\ !ECDSA:CAMELLIA256-SHA:AES256-SHA:CAMELLIA128-SHA:AES128-SHA' RemoteIPHeader X-Forwarded-For RemoteIPTrustedProxy 192.168.0.10/32 Alias /static/ /srv/daiquiri/app/static_root/ <Directory /srv/daiquiri/app/static_root/> Require all granted </Directory> Alias /cms/ /opt/wordpress/ <Directory /opt/wordpress/> AllowOverride all Require all granted </Directory> ProxyPass /static ! ProxyPass /cms ! ProxyPass / http://localhost:9000/ ProxyPassReverse / http://localhost:9000/ <Location /cms/wp-json/> Deny from all </Location> </VirtualHost> The RemoteIPHeader implies that the remoteip module for Apache is installed and enabled. Up to date TLS/SSL settings can be found on bettercrypto.org .","title":"Double reverse proxy setup"},{"location":"advanced/#daiquiri-client","text":"Daiquiri client is a is a python library meant to be used with the Daiquiri Framework. It provides a set of functions which can be used to use the API of a Daiquiri powered website inside a script. The nessesarry HTTP requests are abstracted in a transparent way. Daiquiri client can be installed using pip install --upgrade https://github.com/django-daiquiri/client A script for getting the emails of all users using Daiquiri Client could look like this: from daiquiri_client import Client client = Client(DAIQUIRI_URL, TOKEN) for profile in client.auth.get_profiles(): print(profile['user']['email']) where DAIQUIRI_URL is the url of the Daiquiri site and TOKEN is your API token, which can be obtained from the Daiquiri site at the URL /accounts/token/ . A commen use case for Daiquiri client is the update of the metadata of a database schema. For this, first add the schema manually using the metadate management and make sure Automatically discover tables and columns is checked. Then prepare a yaml file of the form: - name: daiquiri_data_obs title: Observational data description: Some observational data long_description: Some more information about the data. attribution: Please cite the following paper ... order: 1 license: CC0 doi: 10.1000/xyz123 published: 2020-01-01 updated: 2018-01-01 access_level: PUBLIC metadata_access_level: PUBLIC creators: - name: Anna Admin first_name: Anna last_name: Admin orcid: https://orcid.org/0000-0001-2345-6789 affiliations: \"Institute of applied Administration\\nInstitute of theoretical Managament\" - name: Manni Manager orcid: https://orcid.org/0000-0001-2345-6790 affiliations: Institute of theoretical Managament contributors: - name: Some computer guy tables: - name: stars title: Stars description: Some stars data order: 1 license: CC0 doi: 10.1000/xyz123/123 published: 2020-01-01 updated: 2018-01-01 access_level: PUBLIC metadata_access_level: PUBLIC creators: - name: Anna Admin first_name: Anna last_name: Admin orcid: https://orcid.org/0000-0001-2345-6789 affiliations: - Institute of applied Administration - Institute of theoretical Managament - name: Manni Manager orcid: https://orcid.org/0000-0001-2345-6790 affiliations: - Institute of theoretical Managament columns: - name: id ucd: meta.id;meta.main - name: ra ucd: pos.eq.ra;meta.main - name: dec ucd: pos.eq.dec;meta.main - name: parallax ucd: pos.parallax and a python script or notebook with the following content: import yaml from daiquiri_client import Client DAIQUIRI_URL = 'http://localhost:8000' TOKEN = 'a35b0eb94ef906648445c9214bed30265af1062d' with open('update_metadata.yml') as f: local_schemas = yaml.safe_load(f.read()) client = Client(DAIQUIRI_URL, TOKEN) for remote_schema in client.metadata.get_schemas(nested=True): for local_schema in local_schemas: if remote_schema['name'] == local_schema['name']: client.metadata.update_schema(remote_schema['id'], local_schema) for remote_table in remote_schema['tables']: for local_table in local_schema['tables']: if remote_table['name'] == local_table['name']: client.metadata.update_table(remote_table['id'], local_table) for remote_column in remote_table['columns']: for local_column in local_table['columns']: if remote_column['name'] == local_column['name']: client.metadata.update_column(remote_column['id'], local_column) And execute it in a virtual environment where daiquiri_client is installed.","title":"Daiquiri client"},{"location":"deployment/","text":"Deployment Configuration In production, you should create a dedicated user for your Daiquiri application. All steps for the installation, which do not need root access, should be done using this user. As before, we assume this user is called daiquiri and it\u2019s home is /srv/daiquiri and therefore your app is located in /srv/daiquiri/app . In addition, a few more settings need to be configured in your .env file. The most important change is to set DEBUG=False . DEBUG=False ALLOWED_HOSTS=<hostname> # ADMINS will get E-Mails in case of an error ADMINS=Anna Admin <admin@example.com>, Manni Manager <manager@example.com> LOG_DIR=/var/log/django/daiquiri Web server Daiquiri can be run in different configurations, both with Apache2 and NGINX as web server. Daiquiri itself is using the wsgi protocol for the communication between the HTTP and the Python layer. The recommended way of deploying Daiquiri is using Apache2 as a reverse proxy and Gunicorn as wsgi server. For this setup, you need to add: PROXY=True to your .env file. First install Gunicorn inside your virtual environment: pip install gunicorn Then, test gunicorn using: gunicorn --bind 0.0.0.0:8000 config.wsgi:application This should serve the application like runserver , but without the static assets, like CSS files and images. After the test kill the gunicorn process again. Systemd will launch the gunicorn process on startup and keep running. In order to start/restart/stop the web application as well as the asyncronous workers with one command, first create a pseudo-service for your Daiquiri application by creating the file /etc/systemd/system/daiquiri.service (you will need root/sudo permissions for that): [Unit] Description=pseudo-service for all Daiquiri services [Service] Type=oneshot ExecStart=/bin/true RemainAfterExit=yes [Install] WantedBy=network.target Then create the systemd service file for the actual web application in /etc/systemd/system/daiquiri-app.service : [Unit] Description=Daiquiri gunicorn daemon PartOf=daiquiri.service After=daiquiri.service [Service] User=daiquiri Group=daiquiri WorkingDirectory=/srv/daiquiri/app EnvironmentFile=/srv/daiquiri/app/.env Environment=GUNICORN_BIN=/srv/daiquiri/app/env/bin/gunicorn Environment=GUNICORN_WORKER=5 Environment=GUNICORN_PORT=9000 Environment=GUNICORN_TIMEOUT=120 Environment=GUNICORN_PID_FILE=/var/run/gunicorn/daiquiri/pid Environment=GUNICORN_ACCESS_LOG_FILE=/var/log/gunicorn/daiquiri/access.log Environment=GUNICORN_ERROR_LOG_FILE=/var/log/gunicorn/daiquiri/error.log ExecStart=/bin/sh -c '${GUNICORN_BIN} \\ --workers ${GUNICORN_WORKER} \\ --pid ${GUNICORN_PID_FILE} \\ --bind localhost:${GUNICORN_PORT} \\ --timeout ${GUNICORN_TIMEOUT} \\ --access-logfile ${GUNICORN_ACCESS_LOG_FILE} \\ --error-logfile ${GUNICORN_ERROR_LOG_FILE} \\ config.wsgi:application' ExecReload=/bin/sh -c '/usr/bin/pkill -HUP -F ${GUNICORN_PID_FILE}' ExecStop=/bin/sh -c '/usr/bin/pkill -TERM -F ${GUNICORN_PID_FILE}' [Install] WantedBy=daiquiri.target The setup needs to have several directories for logfiles set up with the correct permissions. This can be done using tmpfiles.d . First, create a file /etc/tmpfiles.d/daiquiri.conf : d /run/celery/daiquiri 750 daiquiri daiquiri d /run/gunicorn/daiquiri 750 daiquiri daiquiri d /var/log/django/daiquiri 750 daiquiri daiquiri d /var/log/celery/daiquiri 750 daiquiri daiquiri d /var/log/gunicorn/daiquiri 755 daiquiri daiquiri Then run: systemd-tmpfiles --create The daiquiri systemd service needs to be started and enabled like any other service: sudo systemctl daemon-reload sudo systemctl start daiquiri sudo systemctl enable daiquiri Next, install the web server. On Debian/Ubuntu use: sudo apt install apache2 libapache2-mod-xsendfile sudo a2enmod proxy sudo a2enmod remoteip sudo a2enmod headers and on CentOS 7/8 use sudo yum install httpd mod_xsendfile Then, edit the virtual host configuration to create a reverse proxy to the Gunicorn server: # in /etc/apache2/sites-available/000-default.conf on Debian/Ubuntu # in /etc/httpd/conf.d/vhost.conf on RHEL/CentOS <VirtualHost *:80> ... DocumentRoot \"/var/www/html\" XSendFile on XSendFilePath <FILES_BASE_PATH from the Daiquiri settings> XSendFilePath <QUERY_DOWNLOAD_PATH from the Daiquiri settings> RequestHeader set X-Forwarded-Proto 'https' env=HTTPS ProxyPass /static ! ProxyPass /cms ! ProxyPass / http://localhost:9000/ ProxyPassReverse /dev http://localhost:9000/ Alias /static/ /srv/daiquiri/app/static_root/ <Directory /srv/daiquiri/app/static_root/> Require all granted </Directory> # if you intent to use the WordPress integration Alias /cms/ /opt/wordpress/ <Directory /opt/wordpress/> AllowOverride all Require all granted </Directory> <Location /cms/wp-json/> Deny from all </Location> </VirtualHost> On CentOS selinux needs to be set to persive (or configured properly): setenforce permissive Start the Apache server: sudo systemctl restart apache2 # on Debian/Ubuntu sudo systemctl restart httpd # on RHEL/CentOS Your Daiquiri app should now be available on the configured virtual host, but again, without the static assets, like CSS files and images. Static assets As you can see from the virtual host configurations, the static assets such as CSS and JavaScript files are served independently from the WSGI-python script. In order to do so, they need to be gathered in the static_root directory. This can be achieved by running: python manage.py collectstatic in your virtual environment. The Apache user needs to have read permissions to /srv/daiquiri/app/static_root/ . In order to apply changes to the code, the daiquiri-app job needs to be reloaded. Asyncronous workers In production, and especially if you intent to run several Daiquiri applications on the same RabbitMQ instance, it is recomended to use virtual hosts and users with RabbitMQ. In order to create a virtual host and a user use the following commands on your RabbitMQ host: # first enable the managemetn interface and crate an admin user rabbitmq-plugins enable rabbitmq_management rabbitmqctl add_user admin <a secret password> rabbitmqctl set_user_tags admin administrator # then create a vhost and a user for your daiquiri app rabbitmqctl add_vhost <vhost> rabbitmqctl add_user <user> <a secret password> rabbitmqctl set_permissions -p <user> <user> \".*\" \".*\" \".*\" rabbitmqctl set_permissions -p <user> admin \".*\" \".*\" \".*\" Then add CELERY_BROKER_URL to the .env file of your Daiquiri application: CELERY_BROKER_URL=amqp://<user>:<password>@<host>:<port>/<vhost> As with the Gunicorn process, the asyncronous workers are also using systemd to launch and keep running. Create the following service files for the three workers: # in /etc/systemd/system/daiquiri-default-worker.service [Unit] Description=celery worker for the default queue PartOf=daiquiri.service After=daiquiri.service [Service] Type=forking User=daiquiri Group=daiquiri WorkingDirectory=/srv/daiquiri/app EnvironmentFile=/srv/daiquiri/app/.env Environment=CELERY_BIN=/srv/daiquiri/app/env/bin/celery Environment=CELERYD_NODE=daiquiri_default Environment=CELERYD_QUEUE=default Environment=CELERYD_CONCURRENCY=1 Environment=CELERYD_PID_FILE=/var/run/celery/daiquiri/default.pid Environment=CELERYD_LOG_FILE=/var/log/celery/daiquiri/default.log Environment=CELERYD_LOG_LEVEL=INFO ExecStart=/bin/sh -c '${CELERY_BIN} multi start ${CELERYD_NODE} \\ -A config \\ -Q ${CELERYD_QUEUE} \\ -c ${CELERYD_CONCURRENCY} \\ --pidfile=${CELERYD_PID_FILE} \\ --logfile=${CELERYD_LOG_FILE} \\ --loglevel=${CELERYD_LOG_LEVEL}' ExecStop=/bin/sh -c '${CELERY_BIN} multi stopwait ${CELERYD_NODE} \\ --pidfile=${CELERYD_PID_FILE}' ExecReload=/bin/sh -c '${CELERY_BIN} multi restart ${CELERYD_NODE} \\ -A config \\ -Q ${CELERYD_QUEUE} \\ -c ${ELERYD_CONCURRENCY} \\ --pidfile=${CELERYD_PID_FILE} \\ --logfile=${CELERYD_LOG_FILE} \\ --loglevel=${CELERYD_LOG_LEVEL}' [Install] WantedBy=daiquiri.service # in /etc/systemd/system/daiquiri-query-worker.service [Unit] Description=celery worker for the query queue PartOf=daiquiri.service After=daiquiri.service [Service] Type=forking User=daiquiri Group=daiquiri WorkingDirectory=/srv/daiquiri/app EnvironmentFile=/srv/daiquiri/app/.env Environment=CELERY_BIN=/srv/daiquiri/app/env/bin/celery Environment=CELERYD_NODE=daiquiri_query Environment=CELERYD_QUEUE=query Environment=CELERYD_CONCURRENCY=1 Environment=CELERYD_PID_FILE=/var/run/celery/daiquiri/query.pid Environment=CELERYD_LOG_FILE=/var/log/celery/daiquiri/query.log Environment=CELERYD_LOG_LEVEL=INFO ExecStart=/bin/sh -c '${CELERY_BIN} multi start ${CELERYD_NODE} \\ -A config \\ -Q ${CELERYD_QUEUE} \\ -c ${CELERYD_CONCURRENCY} \\ --pidfile=${CELERYD_PID_FILE} \\ --logfile=${CELERYD_LOG_FILE} \\ --loglevel=${CELERYD_LOG_LEVEL}' ExecStop=/bin/sh -c '${CELERY_BIN} multi stopwait ${CELERYD_NODE} \\ --pidfile=${CELERYD_PID_FILE}' ExecReload=/bin/sh -c '${CELERY_BIN} multi restart ${CELERYD_NODE} \\ -A config \\ -Q ${CELERYD_QUEUE} \\ -c ${ELERYD_CONCURRENCY} \\ --pidfile=${CELERYD_PID_FILE} \\ --logfile=${CELERYD_LOG_FILE} \\ --loglevel=${CELERYD_LOG_LEVEL}' [Install] WantedBy=daiquiri.service # in /etc/systemd/system/daiquiri-download-worker.service [Unit] Description=celery worker for the download queue PartOf=daiquiri.service After=daiquiri.service [Service] Type=forking User=daiquiri Group=daiquiri WorkingDirectory=/srv/daiquiri/app EnvironmentFile=/srv/daiquiri/app/.env Environment=CELERY_BIN=/srv/daiquiri/app/env/bin/celery Environment=CELERYD_NODE=daiquiri_download Environment=CELERYD_QUEUE=download Environment=CELERYD_CONCURRENCY=1 Environment=CELERYD_PID_FILE=/var/run/celery/daiquiri/download.pid Environment=CELERYD_LOG_FILE=/var/log/celery/daiquiri/download.log Environment=CELERYD_LOG_LEVEL=INFO ExecStart=/bin/sh -c '${CELERY_BIN} multi start ${CELERYD_NODE} \\ -A config \\ -Q ${CELERYD_QUEUE} \\ -c ${CELERYD_CONCURRENCY} \\ --pidfile=${CELERYD_PID_FILE} \\ --logfile=${CELERYD_LOG_FILE} \\ --loglevel=${CELERYD_LOG_LEVEL}' ExecStop=/bin/sh -c '${CELERY_BIN} multi stopwait ${CELERYD_NODE} \\ --pidfile=${CELERYD_PID_FILE}' ExecReload=/bin/sh -c '${CELERY_BIN} multi restart ${CELERYD_NODE} \\ -A config \\ -Q ${CELERYD_QUEUE} \\ -c ${CELERYD_CONCURRENCY} \\ --pidfile=${CELERYD_PID_FILE} \\ --logfile=${CELERYD_LOG_FILE} \\ --loglevel=${CELERYD_LOG_LEVEL}' [Install] WantedBy=daiquiri.service Then, the worker can be started and enabled as before: sudo systemctl daemon-reload sudo systemctl start daiquiri-default-worker sudo systemctl start daiquiri-query-worker sudo systemctl start daiquiri-download-worker sudo systemctl enable daiquiri-default-worker sudo systemctl enable daiquiri-query-worker sudo systemctl enable daiquiri-download-worker Caching To use memcached as cache, first install it from the distribution: apt install memcached # Debian/Ubuntu yum install memcached # CentOS On CentOS memcached needs to be restricted to listen only to localhost in /etc/sysconfig/memcached : PORT=\"11211\" USER=\"memcached\" MAXCONN=\"1024\" CACHESIZE=\"64\" OPTIONS=\"-l 127.0.0.1,::1\" Then memcached can be enabled and started: systemctl start memcached systemctl enable memcached","title":"Deployment"},{"location":"deployment/#deployment","text":"","title":"Deployment"},{"location":"deployment/#configuration","text":"In production, you should create a dedicated user for your Daiquiri application. All steps for the installation, which do not need root access, should be done using this user. As before, we assume this user is called daiquiri and it\u2019s home is /srv/daiquiri and therefore your app is located in /srv/daiquiri/app . In addition, a few more settings need to be configured in your .env file. The most important change is to set DEBUG=False . DEBUG=False ALLOWED_HOSTS=<hostname> # ADMINS will get E-Mails in case of an error ADMINS=Anna Admin <admin@example.com>, Manni Manager <manager@example.com> LOG_DIR=/var/log/django/daiquiri","title":"Configuration"},{"location":"deployment/#web-server","text":"Daiquiri can be run in different configurations, both with Apache2 and NGINX as web server. Daiquiri itself is using the wsgi protocol for the communication between the HTTP and the Python layer. The recommended way of deploying Daiquiri is using Apache2 as a reverse proxy and Gunicorn as wsgi server. For this setup, you need to add: PROXY=True to your .env file. First install Gunicorn inside your virtual environment: pip install gunicorn Then, test gunicorn using: gunicorn --bind 0.0.0.0:8000 config.wsgi:application This should serve the application like runserver , but without the static assets, like CSS files and images. After the test kill the gunicorn process again. Systemd will launch the gunicorn process on startup and keep running. In order to start/restart/stop the web application as well as the asyncronous workers with one command, first create a pseudo-service for your Daiquiri application by creating the file /etc/systemd/system/daiquiri.service (you will need root/sudo permissions for that): [Unit] Description=pseudo-service for all Daiquiri services [Service] Type=oneshot ExecStart=/bin/true RemainAfterExit=yes [Install] WantedBy=network.target Then create the systemd service file for the actual web application in /etc/systemd/system/daiquiri-app.service : [Unit] Description=Daiquiri gunicorn daemon PartOf=daiquiri.service After=daiquiri.service [Service] User=daiquiri Group=daiquiri WorkingDirectory=/srv/daiquiri/app EnvironmentFile=/srv/daiquiri/app/.env Environment=GUNICORN_BIN=/srv/daiquiri/app/env/bin/gunicorn Environment=GUNICORN_WORKER=5 Environment=GUNICORN_PORT=9000 Environment=GUNICORN_TIMEOUT=120 Environment=GUNICORN_PID_FILE=/var/run/gunicorn/daiquiri/pid Environment=GUNICORN_ACCESS_LOG_FILE=/var/log/gunicorn/daiquiri/access.log Environment=GUNICORN_ERROR_LOG_FILE=/var/log/gunicorn/daiquiri/error.log ExecStart=/bin/sh -c '${GUNICORN_BIN} \\ --workers ${GUNICORN_WORKER} \\ --pid ${GUNICORN_PID_FILE} \\ --bind localhost:${GUNICORN_PORT} \\ --timeout ${GUNICORN_TIMEOUT} \\ --access-logfile ${GUNICORN_ACCESS_LOG_FILE} \\ --error-logfile ${GUNICORN_ERROR_LOG_FILE} \\ config.wsgi:application' ExecReload=/bin/sh -c '/usr/bin/pkill -HUP -F ${GUNICORN_PID_FILE}' ExecStop=/bin/sh -c '/usr/bin/pkill -TERM -F ${GUNICORN_PID_FILE}' [Install] WantedBy=daiquiri.target The setup needs to have several directories for logfiles set up with the correct permissions. This can be done using tmpfiles.d . First, create a file /etc/tmpfiles.d/daiquiri.conf : d /run/celery/daiquiri 750 daiquiri daiquiri d /run/gunicorn/daiquiri 750 daiquiri daiquiri d /var/log/django/daiquiri 750 daiquiri daiquiri d /var/log/celery/daiquiri 750 daiquiri daiquiri d /var/log/gunicorn/daiquiri 755 daiquiri daiquiri Then run: systemd-tmpfiles --create The daiquiri systemd service needs to be started and enabled like any other service: sudo systemctl daemon-reload sudo systemctl start daiquiri sudo systemctl enable daiquiri Next, install the web server. On Debian/Ubuntu use: sudo apt install apache2 libapache2-mod-xsendfile sudo a2enmod proxy sudo a2enmod remoteip sudo a2enmod headers and on CentOS 7/8 use sudo yum install httpd mod_xsendfile Then, edit the virtual host configuration to create a reverse proxy to the Gunicorn server: # in /etc/apache2/sites-available/000-default.conf on Debian/Ubuntu # in /etc/httpd/conf.d/vhost.conf on RHEL/CentOS <VirtualHost *:80> ... DocumentRoot \"/var/www/html\" XSendFile on XSendFilePath <FILES_BASE_PATH from the Daiquiri settings> XSendFilePath <QUERY_DOWNLOAD_PATH from the Daiquiri settings> RequestHeader set X-Forwarded-Proto 'https' env=HTTPS ProxyPass /static ! ProxyPass /cms ! ProxyPass / http://localhost:9000/ ProxyPassReverse /dev http://localhost:9000/ Alias /static/ /srv/daiquiri/app/static_root/ <Directory /srv/daiquiri/app/static_root/> Require all granted </Directory> # if you intent to use the WordPress integration Alias /cms/ /opt/wordpress/ <Directory /opt/wordpress/> AllowOverride all Require all granted </Directory> <Location /cms/wp-json/> Deny from all </Location> </VirtualHost> On CentOS selinux needs to be set to persive (or configured properly): setenforce permissive Start the Apache server: sudo systemctl restart apache2 # on Debian/Ubuntu sudo systemctl restart httpd # on RHEL/CentOS Your Daiquiri app should now be available on the configured virtual host, but again, without the static assets, like CSS files and images.","title":"Web server"},{"location":"deployment/#static-assets","text":"As you can see from the virtual host configurations, the static assets such as CSS and JavaScript files are served independently from the WSGI-python script. In order to do so, they need to be gathered in the static_root directory. This can be achieved by running: python manage.py collectstatic in your virtual environment. The Apache user needs to have read permissions to /srv/daiquiri/app/static_root/ . In order to apply changes to the code, the daiquiri-app job needs to be reloaded.","title":"Static assets"},{"location":"deployment/#asyncronous-workers","text":"In production, and especially if you intent to run several Daiquiri applications on the same RabbitMQ instance, it is recomended to use virtual hosts and users with RabbitMQ. In order to create a virtual host and a user use the following commands on your RabbitMQ host: # first enable the managemetn interface and crate an admin user rabbitmq-plugins enable rabbitmq_management rabbitmqctl add_user admin <a secret password> rabbitmqctl set_user_tags admin administrator # then create a vhost and a user for your daiquiri app rabbitmqctl add_vhost <vhost> rabbitmqctl add_user <user> <a secret password> rabbitmqctl set_permissions -p <user> <user> \".*\" \".*\" \".*\" rabbitmqctl set_permissions -p <user> admin \".*\" \".*\" \".*\" Then add CELERY_BROKER_URL to the .env file of your Daiquiri application: CELERY_BROKER_URL=amqp://<user>:<password>@<host>:<port>/<vhost> As with the Gunicorn process, the asyncronous workers are also using systemd to launch and keep running. Create the following service files for the three workers: # in /etc/systemd/system/daiquiri-default-worker.service [Unit] Description=celery worker for the default queue PartOf=daiquiri.service After=daiquiri.service [Service] Type=forking User=daiquiri Group=daiquiri WorkingDirectory=/srv/daiquiri/app EnvironmentFile=/srv/daiquiri/app/.env Environment=CELERY_BIN=/srv/daiquiri/app/env/bin/celery Environment=CELERYD_NODE=daiquiri_default Environment=CELERYD_QUEUE=default Environment=CELERYD_CONCURRENCY=1 Environment=CELERYD_PID_FILE=/var/run/celery/daiquiri/default.pid Environment=CELERYD_LOG_FILE=/var/log/celery/daiquiri/default.log Environment=CELERYD_LOG_LEVEL=INFO ExecStart=/bin/sh -c '${CELERY_BIN} multi start ${CELERYD_NODE} \\ -A config \\ -Q ${CELERYD_QUEUE} \\ -c ${CELERYD_CONCURRENCY} \\ --pidfile=${CELERYD_PID_FILE} \\ --logfile=${CELERYD_LOG_FILE} \\ --loglevel=${CELERYD_LOG_LEVEL}' ExecStop=/bin/sh -c '${CELERY_BIN} multi stopwait ${CELERYD_NODE} \\ --pidfile=${CELERYD_PID_FILE}' ExecReload=/bin/sh -c '${CELERY_BIN} multi restart ${CELERYD_NODE} \\ -A config \\ -Q ${CELERYD_QUEUE} \\ -c ${ELERYD_CONCURRENCY} \\ --pidfile=${CELERYD_PID_FILE} \\ --logfile=${CELERYD_LOG_FILE} \\ --loglevel=${CELERYD_LOG_LEVEL}' [Install] WantedBy=daiquiri.service # in /etc/systemd/system/daiquiri-query-worker.service [Unit] Description=celery worker for the query queue PartOf=daiquiri.service After=daiquiri.service [Service] Type=forking User=daiquiri Group=daiquiri WorkingDirectory=/srv/daiquiri/app EnvironmentFile=/srv/daiquiri/app/.env Environment=CELERY_BIN=/srv/daiquiri/app/env/bin/celery Environment=CELERYD_NODE=daiquiri_query Environment=CELERYD_QUEUE=query Environment=CELERYD_CONCURRENCY=1 Environment=CELERYD_PID_FILE=/var/run/celery/daiquiri/query.pid Environment=CELERYD_LOG_FILE=/var/log/celery/daiquiri/query.log Environment=CELERYD_LOG_LEVEL=INFO ExecStart=/bin/sh -c '${CELERY_BIN} multi start ${CELERYD_NODE} \\ -A config \\ -Q ${CELERYD_QUEUE} \\ -c ${CELERYD_CONCURRENCY} \\ --pidfile=${CELERYD_PID_FILE} \\ --logfile=${CELERYD_LOG_FILE} \\ --loglevel=${CELERYD_LOG_LEVEL}' ExecStop=/bin/sh -c '${CELERY_BIN} multi stopwait ${CELERYD_NODE} \\ --pidfile=${CELERYD_PID_FILE}' ExecReload=/bin/sh -c '${CELERY_BIN} multi restart ${CELERYD_NODE} \\ -A config \\ -Q ${CELERYD_QUEUE} \\ -c ${ELERYD_CONCURRENCY} \\ --pidfile=${CELERYD_PID_FILE} \\ --logfile=${CELERYD_LOG_FILE} \\ --loglevel=${CELERYD_LOG_LEVEL}' [Install] WantedBy=daiquiri.service # in /etc/systemd/system/daiquiri-download-worker.service [Unit] Description=celery worker for the download queue PartOf=daiquiri.service After=daiquiri.service [Service] Type=forking User=daiquiri Group=daiquiri WorkingDirectory=/srv/daiquiri/app EnvironmentFile=/srv/daiquiri/app/.env Environment=CELERY_BIN=/srv/daiquiri/app/env/bin/celery Environment=CELERYD_NODE=daiquiri_download Environment=CELERYD_QUEUE=download Environment=CELERYD_CONCURRENCY=1 Environment=CELERYD_PID_FILE=/var/run/celery/daiquiri/download.pid Environment=CELERYD_LOG_FILE=/var/log/celery/daiquiri/download.log Environment=CELERYD_LOG_LEVEL=INFO ExecStart=/bin/sh -c '${CELERY_BIN} multi start ${CELERYD_NODE} \\ -A config \\ -Q ${CELERYD_QUEUE} \\ -c ${CELERYD_CONCURRENCY} \\ --pidfile=${CELERYD_PID_FILE} \\ --logfile=${CELERYD_LOG_FILE} \\ --loglevel=${CELERYD_LOG_LEVEL}' ExecStop=/bin/sh -c '${CELERY_BIN} multi stopwait ${CELERYD_NODE} \\ --pidfile=${CELERYD_PID_FILE}' ExecReload=/bin/sh -c '${CELERY_BIN} multi restart ${CELERYD_NODE} \\ -A config \\ -Q ${CELERYD_QUEUE} \\ -c ${CELERYD_CONCURRENCY} \\ --pidfile=${CELERYD_PID_FILE} \\ --logfile=${CELERYD_LOG_FILE} \\ --loglevel=${CELERYD_LOG_LEVEL}' [Install] WantedBy=daiquiri.service Then, the worker can be started and enabled as before: sudo systemctl daemon-reload sudo systemctl start daiquiri-default-worker sudo systemctl start daiquiri-query-worker sudo systemctl start daiquiri-download-worker sudo systemctl enable daiquiri-default-worker sudo systemctl enable daiquiri-query-worker sudo systemctl enable daiquiri-download-worker","title":"Asyncronous workers"},{"location":"deployment/#caching","text":"To use memcached as cache, first install it from the distribution: apt install memcached # Debian/Ubuntu yum install memcached # CentOS On CentOS memcached needs to be restricted to listen only to localhost in /etc/sysconfig/memcached : PORT=\"11211\" USER=\"memcached\" MAXCONN=\"1024\" CACHESIZE=\"64\" OPTIONS=\"-l 127.0.0.1,::1\" Then memcached can be enabled and started: systemctl start memcached systemctl enable memcached","title":"Caching"},{"location":"installation/","text":"Installation The installation procedure below might be outdated and will be updated soon. Currently, we are using our containerization setup \u2018dq-dev\u2019 which simplifies things quiet a bit. Installation with dq-dev Clone dq-dev and the default daiquiri-app git clone https://github.com/django-daiquiri/app.git git clone https://github.com/django-daiquiri/dq-dev.git Install dq-dev packages cd dq-dev pip install . Create new profile in dq-dev and then activate it python manage.py -c myapp python manage.py -s myapp Set the absolute path to the default app on your system in dq-dev/usr/profiles/myapp/conf.toml [folders_on_host] dq_app = '/path/to/the/default/app' The other dq_app variable should remain untouched [docker_volume_mountpoints] dq_app = \"/home/dq/app\" Important : Make sure that all dq_source variables in conf.toml are commented out. 5. Run dq-dev containerization in the dq-dev folder python manage.py -r Wait until the containers are up and running. Then you can access the default app at http://localhost:9280 If you run into any problems, don\u2019t hesitate to write an issue for dq-dev (https://github.com/django-daiquiri/dq-dev/issues) Outdated installation notes A usual installation of Daiquiri contains of a set of different components: A directory holding all the settings and customisations, custom to your installation of Daiquiri. We will call this directory app , but you can use any name you see fit. This app directory corresponds to a project in Django terms. The django-daiquiri library , which is centrally maintained, and which is installed as a packacge using pip . The application database to store the content, which is generated by the users of your Daiquiri installation. Currently, we support PostgreSQL and MySQL (deprecated). A (bigger) scientific database , where the actual science data is stored. This can be PostgreSQL and MySQL (deprecated). A directory on your filesystem with static files to be downloaded. A RabbitMQ installation as message broker for the asyncronous queues. For testing and development, you can run Daiquiri using your regular user account. On a production system, a dedicated user account should be used. For this documentation we will use a user called daiquiri with the group daiquiri and the home directory /srv/daiquiri . This user can be created with: useradd -m -d /srv/daiquiri -c \"Daiquiri user\" -s /bin/bash daiquiri Do not use the root user to run Daiquiri! It is a bad idea anyway and several steps of the installation will not work. sudo is used in the installation when requiring root-privileges to install packages. Prerequisites Although, most dependencies are installed from the Python Package Index, some dependecies need to be installed using the operation systems packages manager. Here we document the minimum prerequisites: # Centos yum install -y \\ epel-release \\ git \\ gcc gcc-c++ \\ libxml2-devel libxslt-devel \\ openssl-devel \\ python3-devel # Debian or Ubuntu apt-get install -y \\ git \\ build-essential \\ libxml2-dev libxslt-dev \\ zlib1g-dev \\ libssl-dev \\ python3-dev \\ python3-venv Obtaining the app directory The next step is to create the app directory by cloning the corresponding repository. git clone https://github.com/django-daiquiri/app Note that this is not the main django-daiquiri repository, only the configuration files. Inside this directory, you will find: a config directory, containing the main settings of your Daiquiri installation, a manage.py script, which is the main way to interact with your Daiquiri installation on the command line. Most of the following steps will use this script. Install Python packages After you have obtained the app , you need to install the django-daiquiri package and the other python dependencies. Change to the app directory and create a Virtual Environment (this is done as your user or the created daiquiri user, not as root ): cd app python3 -m venv env source env/bin/activate pip install --upgrade pip setuptools wheel After the virtual environment is activated, the django-daiquiri package can be installed using pip : pip install django-daiquiri If you want to install the current master branch directly from GutHub, you alternatively use: pip install git+https://github.com/django-daiquiri/daiquiri The virtual environment encapsulates your Daiquiri installation from the rest of the system. This makes it possible to run several applications with different python dependencies on one machine and to install the dependencies without root permissions. Important: The virtual enviroment needs to be activated, using source env/bin/activate everytime a new terminal is used. This can be automated using your .bashrc . Basic setup The settings of a Daiquiri application are specified in two files: config/settings/base.py should be part of the app repository and holds the basic settings for this particular site. .env is excluded from the repository and should contain (possible secret information) about this machine. This file will be different on the development and the production system. To set up the application, you need to create a new file .env in your cloned app directory. You can use .env.sample as template, i.e.: cp .env.sample .env The different settings are explained in detail later in the documentation . For a minimal configuration, you need to set SECRET_KEY=<a secret random string> SITE_URL=http://localhost:8000 DEBUG=True ASYNC=False DATABASE_DEFAULT=postgresql://<user>:<pass>@<host>/<db> DATABASE_DATA=postgresql://<user>:<pass>@<host>/<db> FILES_BASE_PATH=files QUERY_DOWNLOAD_DIR=download QUERY_UPLOAD_DIR=upload Databases As mentioned earlier, Daiquiri uses two separate database connections, one for the web application ( default ) and one for the scientific data ( data ). These database can be on different machines and you can even use MySQL for one and PostgreSQL for the other. For an SQLite3 database use sqlite:///database.sqlite3 to create the database in the app directory. For PostgreSQL and peer auth use postgresql://@/<db> . Note: The queryparser has dropped the active support of MySQL, thus we strongly recommend to use PostgreSQL. In order to use the different database connections, install the corresponding package with pip : pip install psycopg[binary] # for PostgreSQL pip install mysqlclient # for MySQL or MariaDB Note: For the full ADQL support, it is required to install the pg_sphere extension on the data PostgreSQL database. It is not required for the default database. In your virtualenv, you can get the, which you need to perform on your database with the sqlcreate command: python manage.py sqlcreate Initialization After editing the settings, initialize the application using: python manage.py migrate # initializes the web database python manage.py migrate --database tap # initializes the tap schema in the scientific db python manage.py migrate --database oai # initializes the oai schema in the scientific db python manage.py createsuperuser # creates an admin user python manage.py download_vendor_files # dowloads front-end files from the CDN After these steps, Daiquiri can be run using Django\u2019s intergrated development server: python manage.py runserver Then, Daiquiri is available on http://127.0.0.1:8000 in your (local) browser. Asyncronous tasks Several tasks in Daiquiri can make use of asyncronous tasks (e.g. scientic database queries). Daiquiri can be used without asyncronous tasks, but for any deployment setup this functionality is recomended. RabbiMQ needs to be installed for asyncronous tasks to work. For Debian and Ubuntu, RabbitMQ can be installed from the distribution: apt-get install rabbitmq-server For Centos 7/8, the offical repo needs to be installed as well as its erlang dependencies. This can be done from packagecloud.io : # see also https://www.rabbitmq.com/install-rpm.html curl -s https://packagecloud.io/install/repositories/rabbitmq/erlang/script.rpm.sh | sudo bash curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.rpm.sh | sudo bash yum install rabbitmq-server systemctl start rabbitmq-server systemctl enable rabbitmq-server The asyncronous tasks can be activated the .env file of your Daiquiri application: ASYNC=True For a more complicated RabbitMQ setup the CELERY_BROKER_URL setting is used as explained here . Daiquiri uses 3 different workers: default : For miscanelous database queries performed by users. query : For asynconous database queriesperformed by users. download : For the server-side creation of download files and zip archives. In a development setup these workers can be started using: python manage.py runworker default python manage.py runworker query python manage.py runworker download in your virtual app.","title":"Installation"},{"location":"installation/#installation","text":"The installation procedure below might be outdated and will be updated soon. Currently, we are using our containerization setup \u2018dq-dev\u2019 which simplifies things quiet a bit.","title":"Installation"},{"location":"installation/#installation-with-dq-dev","text":"Clone dq-dev and the default daiquiri-app git clone https://github.com/django-daiquiri/app.git git clone https://github.com/django-daiquiri/dq-dev.git Install dq-dev packages cd dq-dev pip install . Create new profile in dq-dev and then activate it python manage.py -c myapp python manage.py -s myapp Set the absolute path to the default app on your system in dq-dev/usr/profiles/myapp/conf.toml [folders_on_host] dq_app = '/path/to/the/default/app' The other dq_app variable should remain untouched [docker_volume_mountpoints] dq_app = \"/home/dq/app\" Important : Make sure that all dq_source variables in conf.toml are commented out. 5. Run dq-dev containerization in the dq-dev folder python manage.py -r Wait until the containers are up and running. Then you can access the default app at http://localhost:9280 If you run into any problems, don\u2019t hesitate to write an issue for dq-dev (https://github.com/django-daiquiri/dq-dev/issues)","title":"Installation with dq-dev"},{"location":"installation/#outdated-installation-notes","text":"A usual installation of Daiquiri contains of a set of different components: A directory holding all the settings and customisations, custom to your installation of Daiquiri. We will call this directory app , but you can use any name you see fit. This app directory corresponds to a project in Django terms. The django-daiquiri library , which is centrally maintained, and which is installed as a packacge using pip . The application database to store the content, which is generated by the users of your Daiquiri installation. Currently, we support PostgreSQL and MySQL (deprecated). A (bigger) scientific database , where the actual science data is stored. This can be PostgreSQL and MySQL (deprecated). A directory on your filesystem with static files to be downloaded. A RabbitMQ installation as message broker for the asyncronous queues. For testing and development, you can run Daiquiri using your regular user account. On a production system, a dedicated user account should be used. For this documentation we will use a user called daiquiri with the group daiquiri and the home directory /srv/daiquiri . This user can be created with: useradd -m -d /srv/daiquiri -c \"Daiquiri user\" -s /bin/bash daiquiri Do not use the root user to run Daiquiri! It is a bad idea anyway and several steps of the installation will not work. sudo is used in the installation when requiring root-privileges to install packages.","title":"Outdated installation notes"},{"location":"installation/#prerequisites","text":"Although, most dependencies are installed from the Python Package Index, some dependecies need to be installed using the operation systems packages manager. Here we document the minimum prerequisites: # Centos yum install -y \\ epel-release \\ git \\ gcc gcc-c++ \\ libxml2-devel libxslt-devel \\ openssl-devel \\ python3-devel # Debian or Ubuntu apt-get install -y \\ git \\ build-essential \\ libxml2-dev libxslt-dev \\ zlib1g-dev \\ libssl-dev \\ python3-dev \\ python3-venv","title":"Prerequisites"},{"location":"installation/#obtaining-the-app-directory","text":"The next step is to create the app directory by cloning the corresponding repository. git clone https://github.com/django-daiquiri/app Note that this is not the main django-daiquiri repository, only the configuration files. Inside this directory, you will find: a config directory, containing the main settings of your Daiquiri installation, a manage.py script, which is the main way to interact with your Daiquiri installation on the command line. Most of the following steps will use this script.","title":"Obtaining the app directory"},{"location":"installation/#install-python-packages","text":"After you have obtained the app , you need to install the django-daiquiri package and the other python dependencies. Change to the app directory and create a Virtual Environment (this is done as your user or the created daiquiri user, not as root ): cd app python3 -m venv env source env/bin/activate pip install --upgrade pip setuptools wheel After the virtual environment is activated, the django-daiquiri package can be installed using pip : pip install django-daiquiri If you want to install the current master branch directly from GutHub, you alternatively use: pip install git+https://github.com/django-daiquiri/daiquiri The virtual environment encapsulates your Daiquiri installation from the rest of the system. This makes it possible to run several applications with different python dependencies on one machine and to install the dependencies without root permissions. Important: The virtual enviroment needs to be activated, using source env/bin/activate everytime a new terminal is used. This can be automated using your .bashrc .","title":"Install Python packages"},{"location":"installation/#basic-setup","text":"The settings of a Daiquiri application are specified in two files: config/settings/base.py should be part of the app repository and holds the basic settings for this particular site. .env is excluded from the repository and should contain (possible secret information) about this machine. This file will be different on the development and the production system. To set up the application, you need to create a new file .env in your cloned app directory. You can use .env.sample as template, i.e.: cp .env.sample .env The different settings are explained in detail later in the documentation . For a minimal configuration, you need to set SECRET_KEY=<a secret random string> SITE_URL=http://localhost:8000 DEBUG=True ASYNC=False DATABASE_DEFAULT=postgresql://<user>:<pass>@<host>/<db> DATABASE_DATA=postgresql://<user>:<pass>@<host>/<db> FILES_BASE_PATH=files QUERY_DOWNLOAD_DIR=download QUERY_UPLOAD_DIR=upload","title":"Basic setup"},{"location":"installation/#databases","text":"As mentioned earlier, Daiquiri uses two separate database connections, one for the web application ( default ) and one for the scientific data ( data ). These database can be on different machines and you can even use MySQL for one and PostgreSQL for the other. For an SQLite3 database use sqlite:///database.sqlite3 to create the database in the app directory. For PostgreSQL and peer auth use postgresql://@/<db> . Note: The queryparser has dropped the active support of MySQL, thus we strongly recommend to use PostgreSQL. In order to use the different database connections, install the corresponding package with pip : pip install psycopg[binary] # for PostgreSQL pip install mysqlclient # for MySQL or MariaDB Note: For the full ADQL support, it is required to install the pg_sphere extension on the data PostgreSQL database. It is not required for the default database. In your virtualenv, you can get the, which you need to perform on your database with the sqlcreate command: python manage.py sqlcreate","title":"Databases"},{"location":"installation/#initialization","text":"After editing the settings, initialize the application using: python manage.py migrate # initializes the web database python manage.py migrate --database tap # initializes the tap schema in the scientific db python manage.py migrate --database oai # initializes the oai schema in the scientific db python manage.py createsuperuser # creates an admin user python manage.py download_vendor_files # dowloads front-end files from the CDN After these steps, Daiquiri can be run using Django\u2019s intergrated development server: python manage.py runserver Then, Daiquiri is available on http://127.0.0.1:8000 in your (local) browser.","title":"Initialization"},{"location":"installation/#asyncronous-tasks","text":"Several tasks in Daiquiri can make use of asyncronous tasks (e.g. scientic database queries). Daiquiri can be used without asyncronous tasks, but for any deployment setup this functionality is recomended. RabbiMQ needs to be installed for asyncronous tasks to work. For Debian and Ubuntu, RabbitMQ can be installed from the distribution: apt-get install rabbitmq-server For Centos 7/8, the offical repo needs to be installed as well as its erlang dependencies. This can be done from packagecloud.io : # see also https://www.rabbitmq.com/install-rpm.html curl -s https://packagecloud.io/install/repositories/rabbitmq/erlang/script.rpm.sh | sudo bash curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.rpm.sh | sudo bash yum install rabbitmq-server systemctl start rabbitmq-server systemctl enable rabbitmq-server The asyncronous tasks can be activated the .env file of your Daiquiri application: ASYNC=True For a more complicated RabbitMQ setup the CELERY_BROKER_URL setting is used as explained here . Daiquiri uses 3 different workers: default : For miscanelous database queries performed by users. query : For asynconous database queriesperformed by users. download : For the server-side creation of download files and zip archives. In a development setup these workers can be started using: python manage.py runworker default python manage.py runworker query python manage.py runworker download in your virtual app.","title":"Asyncronous tasks"},{"location":"management/","text":"Management Some of the functionalities of Daiquiri can be configured using a user friendly managment intreface. This interfacae is meant to be used not only by admins, who could also use the Admin interface , but also regular users, who are members of particular groups. User management URL path: /auth/users/ Group: user_manager Using the AUTH_WORKFLOW setting , Daiquiri can be configured to use an activation or confirmation workflow. Using the activation workflow, after registration, users need to be manually activated. For the confirmation workflow, users need to be confirmed by through the interface, and then activated in a second step, usually ny a script through the API. Contact messages URL path: /contact/messages/ Group: contact_manager Users can send contact messages to the operators of a Daiquiri site. The coantact messages intreface can be used to respond to these messages or mark them as spam. Metadata management URL path: /metadata/management/ Group: metadata_manager The metadata for database schemas, tables and columns, to be used with the query interface can be accessed through the metadata management. From here, all metadata entries can be edited. The metadata is automatically synced to the TAP_SCHEMA in the scientific database. Access to schemas and tables can be restricted to internal users (who are logged in) or made private and only available to certain groups. Query examples URL path: /metadata/management/ Group: metadata_manager The different examples, visible in the query interface can be created and edited using the example queries interface. As with the database schemas and tables, examples can be restricted to internal users (who are logged in) or made private and only available to certain groups. Stats URL path: /stats/management/ Group: stats_manager A (very) basic overview over the statistics of the Daiquiri site is available in the stats management interface.","title":"Management"},{"location":"management/#management","text":"Some of the functionalities of Daiquiri can be configured using a user friendly managment intreface. This interfacae is meant to be used not only by admins, who could also use the Admin interface , but also regular users, who are members of particular groups.","title":"Management"},{"location":"management/#user-management","text":"URL path: /auth/users/ Group: user_manager Using the AUTH_WORKFLOW setting , Daiquiri can be configured to use an activation or confirmation workflow. Using the activation workflow, after registration, users need to be manually activated. For the confirmation workflow, users need to be confirmed by through the interface, and then activated in a second step, usually ny a script through the API.","title":"User management"},{"location":"management/#contact-messages","text":"URL path: /contact/messages/ Group: contact_manager Users can send contact messages to the operators of a Daiquiri site. The coantact messages intreface can be used to respond to these messages or mark them as spam.","title":"Contact messages"},{"location":"management/#metadata-management","text":"URL path: /metadata/management/ Group: metadata_manager The metadata for database schemas, tables and columns, to be used with the query interface can be accessed through the metadata management. From here, all metadata entries can be edited. The metadata is automatically synced to the TAP_SCHEMA in the scientific database. Access to schemas and tables can be restricted to internal users (who are logged in) or made private and only available to certain groups.","title":"Metadata management"},{"location":"management/#query-examples","text":"URL path: /metadata/management/ Group: metadata_manager The different examples, visible in the query interface can be created and edited using the example queries interface. As with the database schemas and tables, examples can be restricted to internal users (who are logged in) or made private and only available to certain groups.","title":"Query examples"},{"location":"management/#stats","text":"URL path: /stats/management/ Group: stats_manager A (very) basic overview over the statistics of the Daiquiri site is available in the stats management interface.","title":"Stats"},{"location":"oai-metadata/","text":"Overview In the following, we show the API of the Daiquiri OAI for the Datacite metadata schema. The entry values for OAI is generated from the four different resources: Metadata model metadata.models SETTINGS constant values, hard encoded in the oai renderer Datalink (Tables and dynamic datalink),which is not implemented in the default daiquiri and is specific for every app. Note: Since in most cases metadata.models.Schema and metadata.models.Table have the same attributes, the source given for a Schema is also valid for the Tables, unless otherwise noted. ID DataCite-Property Source Notes 1 Identifier metadata.models.Schema.doi DOI or default obj/pk 1.a identifierType constant DOI 2 Creator metadata.models.Schema.creator JSON field 2.1 creatorName ..creator.name If not present creator.last_name, creator.first_name 2.2.a nameType ..creator.name_type must be Organizational or Personal 2.2 givenName ..creator.first_name 2.3 familyName ..creator.last_name 2.4 nameIdentifier ..creator.orcid 2.4.a nameIdentifierScheme constant ORCID 2.4.b schemeURI constant http://orcid.org/ 2.5 affiliation ..creator.affiliation List of Dict 2.5.a affiliationIdentifier ..affiliation.affiliation_identifier e.g., https://ror.org/03mrbr458 2.5.b affiliationIdentifierScheme ..affiliation.affiliation_identifier_scheme e.g., ROR 2.5.c schemeURI ..affiliation.scheme_uri e.g., https://ror.org/ 3 Title metadata.models.Schema.title 4 Publisher core.settings.daiquiri.SITE_PUBLISHER 5 PublicationYear metadata.models.Schema.published.year 6 Subject core.setttings.daiquiri.SITE_SUBJECTS.subject 6.a subjectScheme ..SITE_SUBJECTS.subjectScheme 6.b schemeURI ..SITE_SUBJECTS.schemeURI 6.c valueURI ..SITE_SUBJECTS.valueURI 7 Contributor metadata.models.Schema.contributors JSON Field (list of dict) 7.a contributorType ..contributor.contributor_type If not present, DataManager 7.1 creatorName ..contributor.name If not present ..contributor.last_name, ..contributor.first_name 7.2.a nameType ..contributor.name_type must be Organizational or Personal 7.2 givenName ..contributor.first_name 7.3 familyName ..contributor.last_name 7.4 nameIdentifier ..contributor.orcid 7.4.a nameIdentifierScheme constant ORCID 7.4.b schemeURI constant http://orcid.org/ 7.5 affiliation ..contributor.affiliation List of Dict 7.5.a affiliationIdentifier ..affiliation.affiliation_identifier e.g., https://ror.org/03mrbr458 7.5.b affiliationIdentifierScheme ..affiliation.affiliation_identifier_scheme e.g., ROR 7.5.c schemeURI ..affiliation.scheme_uri e.g., https://ror.org/ 8 Date metadata.models.Schema.updated and ..published 8.a dateType constant Updated and Issued the used value corresponds to Date 9 Language .core.settings.daiquiri.SITE_LANGUAGE 10 ResourceType constant Database table or Database schema 10.a resourceTypeGeneral constant Dataset 11 alternateIdentifier DataciteSchemaSerializer.get_alternate_identifiers abs. url to the metadata of the Table/Schema created on the fly 11.a alternateIdentifierType constant URL 12 RelatedIdentifer metadata.models.Schema.related_identifier JSON Field 12.a relatedIdentifierType ..related_identifier.related_identifer_type 12.b relationType ..related_identifier.relation_type 13 Size DataciteSchemaSerializer.get_alternate_identifiers for schemas: n tables , for tables: <size>n columns</size><size>m rows</size> 14 Format query.settings.QUERY_DOWNLOAD_FORMATS.content_type 15 Version supposed to be at metadata.models.Schema.version Not implemented in metadata. Always empty. 16 Rights DataciteSchemaSerializer.license_label created from metadata.settings.LICENCE_CHOICES via metadata.models.Schema.license 16.a rightURI DataciteSchemaSerializer.license_url created from metadata.settings.LICENCE_URL via metadata.models.Schema.license 16.b rightsIdentifier DataciteSchemaSerializer.license_identifiers created from metadata.settings.LICENCE_IDENTIFIERS via metadata.models.Schema.license 17 Description metadata.models.Schema.long_description If not present or null , metadata.models.Schema.description 17.a descriptionType constant Abstract Additionally, it uses the attribute xml:lang which renders core.settings.daiquiri.SITE_LANGUAGE","title":"OAI Metadata"},{"location":"oai-metadata/#overview","text":"In the following, we show the API of the Daiquiri OAI for the Datacite metadata schema. The entry values for OAI is generated from the four different resources: Metadata model metadata.models SETTINGS constant values, hard encoded in the oai renderer Datalink (Tables and dynamic datalink),which is not implemented in the default daiquiri and is specific for every app. Note: Since in most cases metadata.models.Schema and metadata.models.Table have the same attributes, the source given for a Schema is also valid for the Tables, unless otherwise noted. ID DataCite-Property Source Notes 1 Identifier metadata.models.Schema.doi DOI or default obj/pk 1.a identifierType constant DOI 2 Creator metadata.models.Schema.creator JSON field 2.1 creatorName ..creator.name If not present creator.last_name, creator.first_name 2.2.a nameType ..creator.name_type must be Organizational or Personal 2.2 givenName ..creator.first_name 2.3 familyName ..creator.last_name 2.4 nameIdentifier ..creator.orcid 2.4.a nameIdentifierScheme constant ORCID 2.4.b schemeURI constant http://orcid.org/ 2.5 affiliation ..creator.affiliation List of Dict 2.5.a affiliationIdentifier ..affiliation.affiliation_identifier e.g., https://ror.org/03mrbr458 2.5.b affiliationIdentifierScheme ..affiliation.affiliation_identifier_scheme e.g., ROR 2.5.c schemeURI ..affiliation.scheme_uri e.g., https://ror.org/ 3 Title metadata.models.Schema.title 4 Publisher core.settings.daiquiri.SITE_PUBLISHER 5 PublicationYear metadata.models.Schema.published.year 6 Subject core.setttings.daiquiri.SITE_SUBJECTS.subject 6.a subjectScheme ..SITE_SUBJECTS.subjectScheme 6.b schemeURI ..SITE_SUBJECTS.schemeURI 6.c valueURI ..SITE_SUBJECTS.valueURI 7 Contributor metadata.models.Schema.contributors JSON Field (list of dict) 7.a contributorType ..contributor.contributor_type If not present, DataManager 7.1 creatorName ..contributor.name If not present ..contributor.last_name, ..contributor.first_name 7.2.a nameType ..contributor.name_type must be Organizational or Personal 7.2 givenName ..contributor.first_name 7.3 familyName ..contributor.last_name 7.4 nameIdentifier ..contributor.orcid 7.4.a nameIdentifierScheme constant ORCID 7.4.b schemeURI constant http://orcid.org/ 7.5 affiliation ..contributor.affiliation List of Dict 7.5.a affiliationIdentifier ..affiliation.affiliation_identifier e.g., https://ror.org/03mrbr458 7.5.b affiliationIdentifierScheme ..affiliation.affiliation_identifier_scheme e.g., ROR 7.5.c schemeURI ..affiliation.scheme_uri e.g., https://ror.org/ 8 Date metadata.models.Schema.updated and ..published 8.a dateType constant Updated and Issued the used value corresponds to Date 9 Language .core.settings.daiquiri.SITE_LANGUAGE 10 ResourceType constant Database table or Database schema 10.a resourceTypeGeneral constant Dataset 11 alternateIdentifier DataciteSchemaSerializer.get_alternate_identifiers abs. url to the metadata of the Table/Schema created on the fly 11.a alternateIdentifierType constant URL 12 RelatedIdentifer metadata.models.Schema.related_identifier JSON Field 12.a relatedIdentifierType ..related_identifier.related_identifer_type 12.b relationType ..related_identifier.relation_type 13 Size DataciteSchemaSerializer.get_alternate_identifiers for schemas: n tables , for tables: <size>n columns</size><size>m rows</size> 14 Format query.settings.QUERY_DOWNLOAD_FORMATS.content_type 15 Version supposed to be at metadata.models.Schema.version Not implemented in metadata. Always empty. 16 Rights DataciteSchemaSerializer.license_label created from metadata.settings.LICENCE_CHOICES via metadata.models.Schema.license 16.a rightURI DataciteSchemaSerializer.license_url created from metadata.settings.LICENCE_URL via metadata.models.Schema.license 16.b rightsIdentifier DataciteSchemaSerializer.license_identifiers created from metadata.settings.LICENCE_IDENTIFIERS via metadata.models.Schema.license 17 Description metadata.models.Schema.long_description If not present or null , metadata.models.Schema.description 17.a descriptionType constant Abstract Additionally, it uses the attribute xml:lang which renders core.settings.daiquiri.SITE_LANGUAGE","title":"Overview"},{"location":"settings/","text":"Settings A Daiquiri application can be customised using various settings. Since Daiquiri is based on Django, we use its build-in settings system . Almost every setting has a default value, which is set in the Daiquiri library. The core settings are defined in the daiquiri.core.settings module: daiquiri.core.settings.django daiquiri.core.settings.daiquiri daiquiri.core.settings.logging daiquiri.core.settings.vendor Additional settings, which concern only a single Daiquiri module are defined in the settings module of the particular module: daiquiri.auth.settings daiquiri.conesearch.settings daiquiri.contact.settings daiquiri.cutout.settings daiquiri.files.settings daiquiri.metadata.settings daiquiri.oai.settings daiquiri.query.settings daiquiri.serve.settings daiquiri.stats.settings daiquiri.tap.settings All settings can be changed for your particular app in config/settings/base.py (app specific) or config/settings/local.py (machine specific, and ignored by git). In addition, selected settings can be configured as environment variables, in particular using the .env file app directory: Setting Default SECRET_KEY \ud83d\udeab SITE_URL http://localhost:8000 DEBUG False ASYNC False ALLOWED_HOSTS ['localhost'] TIME_ZONE 'UTC' PROXY False ADMINS [] DATABASE_APP \ud83d\udeab DATABASE_DATA \ud83d\udeab TAP_SCHEMA TAP_SCHEMA TAP_UPLOAD TAP_UPLOAD OAI_SCHEMA OAI_SCHEMA In the .env file, lists are seperated by comma, e.g. ADMINS=Anna Admin <admin@example.com>, Manni Manager <manager@example.com> . Since SECRET_KEY , DATABASE_APP , and DATABASE_DATA have no default value, they need to be set in any case. In the following all settings, which can be changed from their default values to customize you particular Daiquiri app are described in detail: daiquiri.core.settings.django SECRET_KEY Secret key for Django. See also SECRET_KEY in the Django documentation. Should be set in .env . DEBUG Default: False Debug mode. See also DEBUG in the Django documentation. Should be set in .env . BASE_URL Default: / Base URL for the Daiquiri app. Set if your Daiquiri app runs under a alias path on your web server, e.g. /daiquiri/ . ALLOWED_HOSTS Default: ['localhost'] List of allowed hosts for this app. See also ALLOWED_HOSTS in the Django documentation. Should be set in .env . INSTALLED_APPS The list of Django apps for this Daiquiri site. Usually it is set to INSTALLED_APPS = DJANGO_APPS + [ # the list of Daiquiri modules for this site ... ] + ADDITIONAL_APPS See also INSTALLED_APPS in the Django documentation. USER_TABLESPACE Default: 'pg_default' The tablespace where to store the user queryjob tables. Only supported for Postgres DB. TIME_ZONE Default: 'UTC' The time zone for this Daiquiri app (e.g. Europe/Berlin ). ACCOUNT_LOGOUT_ON_GET Default: False Designates if a GET request is sufficient to logout. The seeting needs to be set to TRUE if the WordPress integration is used. ACCOUNT_USERNAME_MIN_LENGTH Default: 4 The minimal length of usernames. ACCOUNT_PASSWORD_MIN_LENGTH Default: 4 The minimal length of passwords. ACCOUNT_EMAIL_VERIFICATION Default: 'mandatory' Designates if new users need to verify their email addresses before logging in. Options are 'mandatory' 'optional' 'none' See also ACCOUNT_EMAIL_VERIFICATION in the django-allauth documentation. ACCOUNT_LOGIN_ON_EMAIL_CONFIRMATION Default: True Designates if new users are automatically logged in after validating their email address. REST_FRAMEWORK Default: { 'DEFAULT_THROTTLE_CLASSES': ( 'rest_framework.throttling.ScopedRateThrottle', ), 'DEFAULT_THROTTLE_RATES': { 'query.create': '10/second' } } Configuration object for the Django REST framework. Used to adjust the maximum rate in which queries are allowed to be submitted (by anyone). See also Throttling in the Django REST framework documentation. CELERY_BROKER_URL Default: amqp:// URL of the RabbitMQ server to be used. For a more sophisticated setup use: CELERY_BROKER_URL=amqp://<user>:<password>@<host>:<port>/<vhost> See also deployment . Should be set in .env . EMAIL_BACKEND Default: 'django.core.mail.backends.console.EmailBackend' Sets the backend used for email delivery. On a production system, this will be django.core.mail.backends.smtp.EmailBackend . For testing/demonstration django.core.mail.backends.console.EmailBackend can be used. See also Sending email in the Django documentation. Can be set in .env . EMAIL_HOST Default: 'localhost' Hostname of the SMTP server. Can be set in .env . EMAIL_PORT Default: '25' Port of the SMTP server. Can be set in .env . EMAIL_HOST_USER Default: '' User for the SMTP server. Can be set in .env . EMAIL_HOST_PASSWORD Default: '' Password for the SMTP server. Can be set in .env . EMAIL_USE_TLS Default: False Designates whether a STARTTLS is used (usually on port 587). Can be set in .env . EMAIL_USE_SSL Default: False Designates whether a implicit TLS connection is used (usually on port 465). Can be set in .env . DEFAULT_FROM_EMAIL Default: '' Sets the FROM field for the E-mails send. Can be set in .env . SENDFILE_BACKEND Default: 'sendfile.backends.simple' Sets the backend used for the sendfile integration to deliver static files. On a production system (using Apache), this will be sendfile.backends.xsendfile . For testing/demonstration sendfile.backends.simple can be used. See also Django Sendfile GitHub readme. MEMCACHE_KEY_PREFIX Default: None Key prefix to use for caching with memcached . Enables caching with memcached. See also deployment . Should be set in .env . daiquiri.core.settings.daiquiri ASYNC Default: False Designates if celery workers are used for asyncronous tasks like query execution. If set to True , three workers need to run: default , query , and download . IPV4_PRIVACY_MASK Default: 16 Number of bits kept from IPv4 addresses (e.g. to produce query stats) for anonymity. IPV6_PRIVACY_MASK Default: 32 Number of bits kept from IPv6 addresses (e.g. to produce query stats) for anonymity. SITE_URL Default: http://localhost:8000 Public URL of the Daiquiri site. Used for VO and OAI metadata. SITE_IDENTIFIER Default: None Identifier for the Daiquiri site. Usually the URL without the protocol. Used for VO and OAI metadata. SITE_TITLE Default: None The title for the Daiquiri site. Used for VO and OAI metadata. SITE_DESCRIPTION Default: None The description for the Daiquiri site. Used for VO and OAI metadata. SITE_LICENSE Default: None A license for the Daiquiri site. See https://github.com/django-daiquiri/daiquiri/blob/master/daiquiri/core/constants.py for the available choices. Used in various metadata fields. SITE_CREATOR Default: None Creator of the Daiquiri site. Used in the VO registry entry. Has to be of the following form: { 'name': 'Daiquiri project' 'logo': None } SITE_CONTACT Default: None List of contacts for the Daiquiri site. Used in the VO registry entry. Has to be of the following form: { 'name': 'Anna Admin' 'address': 'Beispielstr. 3, 12345 Berlin', 'email': 'contact@example.com' 'telephone': '+49 30 123467' } SITE_PUBLISHER Default: None Publisher of the Daiquiri site. Used for VO and OAI metadata. SITE_CREATED Default: None Date of the creation of the Daiquiri site. Used for VO and OAI metadata. Has to be of the form YYYY-MM-DD . SITE_UPDATED Default: None Date of the last update of the Daiquiri site. Used for VO and OAI metadata. Has to be of the form YYYY-MM-DD . SITE_SUBJECTS Default: [ { 'subject': 'Astronomy', 'schemeURI': 'http://id.loc.gov/authorities/subjects', 'valueURI': 'http://id.loc.gov/authorities/subjects/sh85009003' } ] Subjects for this Daiquiri app. Used for VO and OAI metadata. SITE_TYPE Default: 'service' Type for this Daiquiri site. Used in the VO registry entry. daiquiri.core.settings.logging LOG_LEVEL Default: INFO Level of logging. Set to DEBUG to get more verbose logging. Should be set in .env . LOG_DIR Default: None Directory for log files. In development log is suitable, in production /var/log/django/daiquiri/ might be a sensible choice. Note that this directory must exist for Daiquiri to work. Should be set in .env . daiquiri.core.settings.vendor VENDOR_CDN Default: False Use content delivery networks to host the static vendor assets (js and css files). Using the default of False implies that the assets need to be collected using python manage.py download_vendor_files . daiquiri.archive.settings ARCHIVE_BASE_PATH Default: os.path.join(BASE_DIR, 'files') Sets the absolute base path of the files served by the archive module in the local file system. ARCHIVE_DOWNLOAD_DIR Default: os.path.join(BASE_DIR, 'download') Sets the absolute path where the zip files for downloads from the archive are located in the local file system. ARCHIVE_ANONYMOUS Default: False Designates if the archive interface can be accessed by anonymus users. ARCHIVE_SCHEMA Default: 'daiquiri_archive' Sets the schema for the archive in the data database. ARCHIVE_TABLE Default: 'files' Sets the table for the archive in the schema set by ARCHIVE_SCHEMA the data database. ARCHIVE_COLUMNS Default: [ { 'name': 'id', 'hidden': True }, { 'name': 'timestamp', 'label': 'Timestamp' }, { 'name': 'file', 'label': 'Filename', 'ucd': 'meta.file' }, { 'name': 'collection', 'hidden': True }, { 'name': 'path', 'hidden': True } ] Sets the additional columns for the archive in the table set by ARCHIVE_TABLE the data database. daiquiri.auth.settings AUTH_SIGNUP Default: False Designates if users can register for an account. If set to false, all users need to be created through the Django admin system. AUTH_WORKFLOW Default: None Sets the workflow for user registration. Options are None : Newly registered users can log in after registartion. 'activation' : Newly registered users need to be activated by a manager or admin. 'confirmation' : Newly registered users need to be confirmed by a manager before they are activated by an admin. AUTH_DETAIL_KEYS Default: [] Sets additional details to be asked from the users when registering. An example would be: AUTH_DETAIL_KEYS = [ { 'key': 'affiliation', 'label': 'Affiliation', 'data_type': 'text', 'required': True, 'options': [] }, ] where: key is the internal identifier, label the text shown in the interface, datatype the type of the detail which affects the widget to be used ( 'text' , 'textarea' , 'select' , 'radio' , 'multiselect' , or 'checkbox' ), required whether this detail is required or not, and options a list of options for select, radio or checkboxes widgets of the form [{'id': id, 'label': label}, ...] . AUTH_TERMS_OF_USE Default: False Designates whether terms of use are displayed on the signup page and need to be accepted to register. The text of to displayed needs to be configured in a template account/terms_of_use.html . daiquiri.conesearch.settings CONESEARCH_ADAPTER Default: 'daiquiri.conesearch.adapter.SimpleConeSearchAdapter' Sets the adapter class to be used by the cone search api. The adapter class encapsulated all operations creating a cone search votable output from the api request. Custom adapter need to enherit from daiquiri.conesearch.adapter.BaseConeSearchAdapter . CONESEARCH_ANONYMOUS Default: False Designates if cone searches can be done by by anonymous users. daiquiri.contact.settings ANNOUNCEMENT_MESSAGE_FILTER Default: daiquiri.contact.filters.DefaultMessageFilter Sets the filter class to be used by the announcement messages. The filter class encapsulates all filter methods used to show announcements to a filtered set of users. Custom filter class must enherit from daiquiri.contact.filters.DefaultMessageFilter . All custom filter methods are required to have a single parameter request . The announcement messages can be added in the Django admin site. In order to show the messages on a webpage, one has to load the announcement tags in the template {% load announcement_tags %} and then place {% show_announcements %} where the messages should be shown. daiquiri.cutout.settings CUTOUT_ADAPTER Default: 'daiquiri.cutout.adapter.SimpleCutOutAdapter' Sets the adapter class to be used by the cutout api. The adapter class encapsulated all operations creating a cut out from the api request. Custom adapter need to enherit from daiquiri.cutout.adapter.BaseCutOutAdapter . CUTOUT_ANONYMOUS Default: False Designates if the cutout interface can be accessed by anonymus users. daiquiri.files.settings FILES_BASE_PATH Default: os.path.join(BASE_DIR, 'files') Sets the absolute base path of the files served by the files module in the local file system. Should be set in .env . FILES_BASE_URL Default: None Sets the absolute URL for this Daiquiri app to be prepended to file references when downloading query results. This is done for columns with the meta.ref;meta.file , meta.ref;meta.image or meta.ref;meta.note UCD. Should be set in .env . FILES_DOCS_REL_PATH Default: None Sets the relative file path to the documentation files on which the file search will be executed. The path is given relative to the FILES_BASE_PATH . In order to use the search function for the files, one has to include the search field into the template. {% include 'files/search-input.html' %} The layout of the results page can be changed by overloading the template files/search-results.html in the daiquri app. FILES_SEARCH_RESULTS_PER_PAGE Default: 5 Sets the number of search results per page. daiquiri.meetings.settings MEETINGS_CONTRIBUTION_TYPES Default: [ ('talk', _('Talk')), ('poster', _('Poster')) ] Sets the types of contributions to be selected by partcipants when registering. MEETINGS_PAYMENT_CHOICES Default: [ ('cash', _('cash')), ('wire', _('wire transfer')), ] Sets the different payment choices to be selected by partcipants when registering. MEETINGS_PARTICIPANT_DETAIL_KEYS Default: [] Sets additional details to be asked from the participants when registering. An example would be: MEETINGS_PARTICIPANT_DETAIL_KEYS = [ { 'key': 'affiliation', 'label': 'Affiliation', 'data_type': 'text', 'required': True }, { 'key': 'dinner', 'label': 'Conference dinner', 'data_type': 'radio', 'required': True, 'options': [ {'id': 'yes', 'label': 'yes'}, {'id': 'no', 'label': 'no'} ] } ] where: key is the internal identifier, label the text shown in the interface, datatype the type of the detail which affects the widget to be used ( 'text' , 'textarea' , 'select' , 'radio' , 'multiselect' , or 'checkbox' ), required whether this detail is required or not, and options a list of options for select, radio or checkboxes widgets of the form [{'id': id, 'label': label}, ...] . MEETINGS_ABSTRACT_MAX_LENGTH Default: 2000 Sets the maximum lenght of an abstract. daiquiri.metadata.settings METADATA_COLUMN_PERMISSIONS Default: False Designates if permissions can be assigned to individual columns (in addition to tables and schemas). This is an experimental feature. METADATA_BASE_URL Default: None Sets the absolute URL of the metadata module, e.g. http://example.com/metadata/. The URL is used to create links to the landing pages for schemas and tables in VOTables if a DOI is not set. daiquiri.oai.settings OAI_SCHEMA Default: OAI_SCHEMA Sets the name of the schema for OAI records. If more than one Daiquiri application is using the same data database, they cannot use the same OAI_SCHEMA schema. This setting must be set in .env OAI_ADAPTER Default: 'daiquiri.metadata.adapter.RegistryDoiMetadataOaiAdapter' Sets the adapter class to be used by the OAI-PMH api. The adapter class encapsulated all operations to set up and retrieve the OAI records. Custom adapter need to enherit from daiquiri.metadata.adapter.BaseOaiAdapter . Usually this will be done in the Daiquiri app, e.g. OAI_ADAPTER = 'app.adapter.OaiAdapter' OAI_PAGE_SIZE Default: 500 Number of records returned in a OAI-PMH request. daiquiri.query.settings QUERY_ANONYMOUS Default: False Designates if the query interface can be accessed by anonymus users. The permissions on schemas and tables need to be configured using the metadata interface. QUERY_USER_SCHEMA_PREFIX Default: 'daiquiri_user_' Sets the prefix for user schemas in the data database. Each user has a private schema where the result table of successful queries are stored. QUERY_QUOTA Default: { 'anonymous': '100Mb', 'user': '10000Mb', 'users': {}, 'groups': {} } Sets the maximum quota for tables in a user\u2019s personal schema. The quota need to be set for the anonymous user as well as regular loggen in users ( user ). Additionally, users or groups can be asigned individual quotas, e.g.: { 'anonymous': '100Mb', 'user': '10000Mb', 'users': { 'admin': '1000Gb' }, 'groups': { 'collab': '100Gb' } } If more than one quota applies, the maximum is used. QUERY_SYNC_TIMEOUT Default: 5 Sets the timeout for syncronous (TAP) queries in seconds. QUERY_MAX_ACTIVE_JOBS Default: { 'anonymous': '1' } Sets the maximum of simultanous jobs for users. The setting work analog to \u2018QUERY_QUOTA\u2019. If more than one maximum applies, the maximum is used. If no maximum is given, like the default setting for logged users, no maximum is enforced. QUERY_QUEUES Default: [ { 'key': 'default', 'label': 'Default', 'timeout': 10, 'priority': 1, 'access_level': 'PUBLIC', 'groups': [] } ] Set the different queue, which can be selected by the users. Each queue is represented by a dictionary where: key is the internal identifier, label is the text shown in the interface, timeout the maximum excecution time in seconds, priority is a integer number indicationg the priority in which jobs are executed, and access_level and groups the usual restiction on who can use this queue. Jobs in a queue with higher priority are selected first when a query worker becomes available. QUERY_LANGUAGES Default: [ { 'key': 'adql', 'version': 2.0, 'label': 'ADQL', 'description': '', 'quote_char': '\"' } ] Sets the different query languages, which can be selected by the users. Each query language is represented by a dictionary where: key is the internal identifier, label is the text shown in the interface, description is additional information shown, e.g. in TopCat, and quote_char the character used by the database system to quote identifiers. Already implemented in Daiquiri are adql , postgresql , and mysql . Apart from ADQL, the query language must match the database system of the data database. QUERY_FORMS Default: [ { 'key': 'sql', 'label': 'SQL query', 'service': 'query/js/forms/sql.js', 'template': 'query/query_form_sql.html' } ] Sets the form available for the users in the query interface. Each form is represented by a dictionary where: key is the internal identifier, label is the text shown in the interface, service the path AngularJS service containing the client side logic, and template the path to the Django template with the markup for the form. Included in Daiquiri are sql and (simplyfied) cone and box services. QUERY_PLOTS Default: [ { 'key': 'scatter_plot', 'label': 'Scatter', 'is_active': True, }, { 'key': 'scatter_cmap_plot', 'label': 'Scatter (color coded)', 'is_active': True, }, { 'key': 'histogram', 'label': 'Histogram', 'is_active': True, } ] Sets the visibility of the available plot types in the web interface. key is the internal identifier, label is the type name shown in the interface, and is_active controls whether the plot type is used in the interface. QUERY_DROPDOWNS Default: [ { 'key': 'simbad', 'service': 'query/js/dropdowns/simbad.js', 'template': 'query/query_dropdown_simbad.html', 'options': { 'url': 'http://simbad.u-strasbg.fr/simbad/sim-id' } }, { 'key': 'vizier', 'service': 'query/js/dropdowns/vizier.js', 'template': 'query/query_dropdown_vizier.html', 'options': { 'url': 'http://vizier.u-strasbg.fr/viz-bin/votable', 'catalogs': ['I/322A', 'I/259'] } } ] Sets the additional drop down menus above the SQL query interface available for the users. Each drop down is represented by a dictionary where: key is the internal identifier, service the path AngularJS service containing the client side logic, template the path to the Django template with the markup, and options additional options specific to the drop down. Included in Daiquiri are simbad and vizier services. QUERY_DOWNLOAD_DIR Default: os.path.join(BASE_DIR, 'download') Sets the absolute base path of the download files served by the query module in the local file system. QUERY_DEFAULT_DOWNLOAD_FORMAT Default: 'votable' Sets the default download format. QUERY_DOWNLOAD_FORMATS Default: [ { 'key': 'votable', 'extension': 'xml', 'content_type': 'application/xml', 'label': 'IVOA VOTable XML file - TABLEDATA serialization', 'help': 'A XML file using the IVOA VOTable format. Use this option if you intend to use VO compatible software to further process the data.' }, { 'key': 'csv', 'extension': 'csv', 'content_type': 'text/csv', 'label': 'Comma separated Values', 'help': 'A text file with a line for each row of the table. The fields are delimited by a comma and quoted by double quotes. Use this option for a later import into a spreadsheed application or a custom script. Use this option if you are unsure what to use.' }, { 'key': 'fits', 'extension': 'fits', 'content_type': 'application/fits', 'label': 'FITS', 'help': 'Flexible Image Transport System (FITS) file format.' }, { 'key': 'parquet', 'extension': 'parquet', 'content_type': 'application/parquet', 'label': 'Parquet', 'help': 'Apache Parquet file format.', }, ] Sets the available default download formats. Each format is represented by a dictionary where: key is the internal identifier, extension the file extension, content_type the content type, label the text shown in the interface, and help a more verbose help text for the format. NOTE : If you want faster parquet file generation, get the lastest binary of pg2parquet and put it somewhere covered by your PATH variable. This rust-binary is up to 4 times faster as the Python-based fastparquet solution that works as a fallback. QUERY_UPLOAD Default: True Enables the upload functionality in the query interface. QUERY_UPLOAD_LIMIT Default: { 'anonymous': '10Mb', 'user': '100Mb', 'users': {}, 'groups': {} } Sets the maximum quota for uploads by a user. The quota need to be set for the anonymous user as well as regular loggen in users ( user ). Additionally, users or groups can be asigned individual quotas, much like with QUERY_QUOTA . daiquiri.serve.settings SERVE_DOWNLOAD_DIR Default: os.path.join(BASE_DIR, 'download') Sets the absolute base path of the download files served by the serve module in the local file system. SERVE_RESOLVER Default: None Sets the a resolver class to handle references in tables served by the serve module. daiquiri.stats.settings STATS_RESOURCE_TYPES Default: [ { 'key': 'ARCHIVE_DOWNLOAD', 'label': 'Archive downloads' }, { 'key': 'CONESEARCH', 'label': 'Performed cone searches' }, { 'key': 'CUTOUT', 'label': 'Performed cutouts' }, { 'key': 'FILE', 'label': 'File downloads' }, { 'key': 'QUERY', 'label': 'Queries' } ] Sets the aggegated stats shown in the stats management overview. daiquiri.tap.settings TAP_SCHEMA Default: 'TAP_SCHEMA' Sets the name of the TAP schema. If more than one Daiquiri application is using the same data database, they cannot use the same TAP schema. Therefore the schema name TAP_SCHEMA is replaced before queries are submitted. This setting must be set in .env TAP_UPLOAD Default: 'TAP_UPLOAD' Sets the name of the schema for TAP uploads. If more than one Daiquiri application is using the same data database, they cannot use the same TAP_UPLOAD schema. Therefore the schema name TAP_UPLOAD is replaced before queries are submitted. This setting must be set in .env daiquiri.uws.settings UWS_RESOURCES Default: [] Configures UWS services (in addition to the TAP module). E.g.: { 'prefix': r'query', 'viewset': 'daiquiri.query.viewsets.UWSQueryJobViewSet', 'base_name': 'uws_query' } where: prefix is part of the base URL of the service (e.g. http://example.com/usw/query), viewset is the ViewSet class handling the requests (neets to enherit from daiquiri.jobs.viewsets.AsyncJobViewSet ), and base_name a basename needed for the integration in the Django REST framework. daiquiri.wordpress.settings WORDPRESS_PATH Default: '/opt/wordpress' Sets the location of the WordPress installation on the local file system. WORDPRESS_SSH Default: None Sets the destination for a SSH connection to use with wp-cli . Use this setting if WordPress is not installed on the same host as Daiquiri. The local wp-cli will then connect to the remote system using ssh. An example would be: WORDPRESS_SSH=example.com:/opt/daiquiri This option overided WORDPRESS_PATH . WORDPRESS_CLI Default: '/opt/wp-cli/wp' Sets the location of the wp-cli script on the local file system. WORDPRESS_URL Default: '/cms/' Sets the base url of the WordPress instance.","title":"Settings"},{"location":"settings/#settings","text":"A Daiquiri application can be customised using various settings. Since Daiquiri is based on Django, we use its build-in settings system . Almost every setting has a default value, which is set in the Daiquiri library. The core settings are defined in the daiquiri.core.settings module: daiquiri.core.settings.django daiquiri.core.settings.daiquiri daiquiri.core.settings.logging daiquiri.core.settings.vendor Additional settings, which concern only a single Daiquiri module are defined in the settings module of the particular module: daiquiri.auth.settings daiquiri.conesearch.settings daiquiri.contact.settings daiquiri.cutout.settings daiquiri.files.settings daiquiri.metadata.settings daiquiri.oai.settings daiquiri.query.settings daiquiri.serve.settings daiquiri.stats.settings daiquiri.tap.settings All settings can be changed for your particular app in config/settings/base.py (app specific) or config/settings/local.py (machine specific, and ignored by git). In addition, selected settings can be configured as environment variables, in particular using the .env file app directory: Setting Default SECRET_KEY \ud83d\udeab SITE_URL http://localhost:8000 DEBUG False ASYNC False ALLOWED_HOSTS ['localhost'] TIME_ZONE 'UTC' PROXY False ADMINS [] DATABASE_APP \ud83d\udeab DATABASE_DATA \ud83d\udeab TAP_SCHEMA TAP_SCHEMA TAP_UPLOAD TAP_UPLOAD OAI_SCHEMA OAI_SCHEMA In the .env file, lists are seperated by comma, e.g. ADMINS=Anna Admin <admin@example.com>, Manni Manager <manager@example.com> . Since SECRET_KEY , DATABASE_APP , and DATABASE_DATA have no default value, they need to be set in any case. In the following all settings, which can be changed from their default values to customize you particular Daiquiri app are described in detail:","title":"Settings"},{"location":"settings/#daiquiricoresettingsdjango","text":"","title":"daiquiri.core.settings.django"},{"location":"settings/#secret_key","text":"Secret key for Django. See also SECRET_KEY in the Django documentation. Should be set in .env .","title":"SECRET_KEY"},{"location":"settings/#debug","text":"Default: False Debug mode. See also DEBUG in the Django documentation. Should be set in .env .","title":"DEBUG"},{"location":"settings/#base_url","text":"Default: / Base URL for the Daiquiri app. Set if your Daiquiri app runs under a alias path on your web server, e.g. /daiquiri/ .","title":"BASE_URL"},{"location":"settings/#allowed_hosts","text":"Default: ['localhost'] List of allowed hosts for this app. See also ALLOWED_HOSTS in the Django documentation. Should be set in .env .","title":"ALLOWED_HOSTS"},{"location":"settings/#installed_apps","text":"The list of Django apps for this Daiquiri site. Usually it is set to INSTALLED_APPS = DJANGO_APPS + [ # the list of Daiquiri modules for this site ... ] + ADDITIONAL_APPS See also INSTALLED_APPS in the Django documentation.","title":"INSTALLED_APPS"},{"location":"settings/#user_tablespace","text":"Default: 'pg_default' The tablespace where to store the user queryjob tables. Only supported for Postgres DB.","title":"USER_TABLESPACE"},{"location":"settings/#time_zone","text":"Default: 'UTC' The time zone for this Daiquiri app (e.g. Europe/Berlin ).","title":"TIME_ZONE"},{"location":"settings/#account_logout_on_get","text":"Default: False Designates if a GET request is sufficient to logout. The seeting needs to be set to TRUE if the WordPress integration is used.","title":"ACCOUNT_LOGOUT_ON_GET"},{"location":"settings/#account_username_min_length","text":"Default: 4 The minimal length of usernames.","title":"ACCOUNT_USERNAME_MIN_LENGTH"},{"location":"settings/#account_password_min_length","text":"Default: 4 The minimal length of passwords.","title":"ACCOUNT_PASSWORD_MIN_LENGTH"},{"location":"settings/#account_email_verification","text":"Default: 'mandatory' Designates if new users need to verify their email addresses before logging in. Options are 'mandatory' 'optional' 'none' See also ACCOUNT_EMAIL_VERIFICATION in the django-allauth documentation.","title":"ACCOUNT_EMAIL_VERIFICATION"},{"location":"settings/#account_login_on_email_confirmation","text":"Default: True Designates if new users are automatically logged in after validating their email address.","title":"ACCOUNT_LOGIN_ON_EMAIL_CONFIRMATION"},{"location":"settings/#rest_framework","text":"Default: { 'DEFAULT_THROTTLE_CLASSES': ( 'rest_framework.throttling.ScopedRateThrottle', ), 'DEFAULT_THROTTLE_RATES': { 'query.create': '10/second' } } Configuration object for the Django REST framework. Used to adjust the maximum rate in which queries are allowed to be submitted (by anyone). See also Throttling in the Django REST framework documentation.","title":"REST_FRAMEWORK"},{"location":"settings/#celery_broker_url","text":"Default: amqp:// URL of the RabbitMQ server to be used. For a more sophisticated setup use: CELERY_BROKER_URL=amqp://<user>:<password>@<host>:<port>/<vhost> See also deployment . Should be set in .env .","title":"CELERY_BROKER_URL"},{"location":"settings/#email_backend","text":"Default: 'django.core.mail.backends.console.EmailBackend' Sets the backend used for email delivery. On a production system, this will be django.core.mail.backends.smtp.EmailBackend . For testing/demonstration django.core.mail.backends.console.EmailBackend can be used. See also Sending email in the Django documentation. Can be set in .env .","title":"EMAIL_BACKEND"},{"location":"settings/#email_host","text":"Default: 'localhost' Hostname of the SMTP server. Can be set in .env .","title":"EMAIL_HOST"},{"location":"settings/#email_port","text":"Default: '25' Port of the SMTP server. Can be set in .env .","title":"EMAIL_PORT"},{"location":"settings/#email_host_user","text":"Default: '' User for the SMTP server. Can be set in .env .","title":"EMAIL_HOST_USER"},{"location":"settings/#email_host_password","text":"Default: '' Password for the SMTP server. Can be set in .env .","title":"EMAIL_HOST_PASSWORD"},{"location":"settings/#email_use_tls","text":"Default: False Designates whether a STARTTLS is used (usually on port 587). Can be set in .env .","title":"EMAIL_USE_TLS"},{"location":"settings/#email_use_ssl","text":"Default: False Designates whether a implicit TLS connection is used (usually on port 465). Can be set in .env .","title":"EMAIL_USE_SSL"},{"location":"settings/#default_from_email","text":"Default: '' Sets the FROM field for the E-mails send. Can be set in .env .","title":"DEFAULT_FROM_EMAIL"},{"location":"settings/#sendfile_backend","text":"Default: 'sendfile.backends.simple' Sets the backend used for the sendfile integration to deliver static files. On a production system (using Apache), this will be sendfile.backends.xsendfile . For testing/demonstration sendfile.backends.simple can be used. See also Django Sendfile GitHub readme.","title":"SENDFILE_BACKEND"},{"location":"settings/#memcache_key_prefix","text":"Default: None Key prefix to use for caching with memcached . Enables caching with memcached. See also deployment . Should be set in .env .","title":"MEMCACHE_KEY_PREFIX"},{"location":"settings/#daiquiricoresettingsdaiquiri","text":"","title":"daiquiri.core.settings.daiquiri"},{"location":"settings/#async","text":"Default: False Designates if celery workers are used for asyncronous tasks like query execution. If set to True , three workers need to run: default , query , and download .","title":"ASYNC"},{"location":"settings/#ipv4_privacy_mask","text":"Default: 16 Number of bits kept from IPv4 addresses (e.g. to produce query stats) for anonymity.","title":"IPV4_PRIVACY_MASK"},{"location":"settings/#ipv6_privacy_mask","text":"Default: 32 Number of bits kept from IPv6 addresses (e.g. to produce query stats) for anonymity.","title":"IPV6_PRIVACY_MASK"},{"location":"settings/#site_url","text":"Default: http://localhost:8000 Public URL of the Daiquiri site. Used for VO and OAI metadata.","title":"SITE_URL"},{"location":"settings/#site_identifier","text":"Default: None Identifier for the Daiquiri site. Usually the URL without the protocol. Used for VO and OAI metadata.","title":"SITE_IDENTIFIER"},{"location":"settings/#site_title","text":"Default: None The title for the Daiquiri site. Used for VO and OAI metadata.","title":"SITE_TITLE"},{"location":"settings/#site_description","text":"Default: None The description for the Daiquiri site. Used for VO and OAI metadata.","title":"SITE_DESCRIPTION"},{"location":"settings/#site_license","text":"Default: None A license for the Daiquiri site. See https://github.com/django-daiquiri/daiquiri/blob/master/daiquiri/core/constants.py for the available choices. Used in various metadata fields.","title":"SITE_LICENSE"},{"location":"settings/#site_creator","text":"Default: None Creator of the Daiquiri site. Used in the VO registry entry. Has to be of the following form: { 'name': 'Daiquiri project' 'logo': None }","title":"SITE_CREATOR"},{"location":"settings/#site_contact","text":"Default: None List of contacts for the Daiquiri site. Used in the VO registry entry. Has to be of the following form: { 'name': 'Anna Admin' 'address': 'Beispielstr. 3, 12345 Berlin', 'email': 'contact@example.com' 'telephone': '+49 30 123467' }","title":"SITE_CONTACT"},{"location":"settings/#site_publisher","text":"Default: None Publisher of the Daiquiri site. Used for VO and OAI metadata.","title":"SITE_PUBLISHER"},{"location":"settings/#site_created","text":"Default: None Date of the creation of the Daiquiri site. Used for VO and OAI metadata. Has to be of the form YYYY-MM-DD .","title":"SITE_CREATED"},{"location":"settings/#site_updated","text":"Default: None Date of the last update of the Daiquiri site. Used for VO and OAI metadata. Has to be of the form YYYY-MM-DD .","title":"SITE_UPDATED"},{"location":"settings/#site_subjects","text":"Default: [ { 'subject': 'Astronomy', 'schemeURI': 'http://id.loc.gov/authorities/subjects', 'valueURI': 'http://id.loc.gov/authorities/subjects/sh85009003' } ] Subjects for this Daiquiri app. Used for VO and OAI metadata.","title":"SITE_SUBJECTS"},{"location":"settings/#site_type","text":"Default: 'service' Type for this Daiquiri site. Used in the VO registry entry.","title":"SITE_TYPE"},{"location":"settings/#daiquiricoresettingslogging","text":"","title":"daiquiri.core.settings.logging"},{"location":"settings/#log_level","text":"Default: INFO Level of logging. Set to DEBUG to get more verbose logging. Should be set in .env .","title":"LOG_LEVEL"},{"location":"settings/#log_dir","text":"Default: None Directory for log files. In development log is suitable, in production /var/log/django/daiquiri/ might be a sensible choice. Note that this directory must exist for Daiquiri to work. Should be set in .env .","title":"LOG_DIR"},{"location":"settings/#daiquiricoresettingsvendor","text":"","title":"daiquiri.core.settings.vendor"},{"location":"settings/#vendor_cdn","text":"Default: False Use content delivery networks to host the static vendor assets (js and css files). Using the default of False implies that the assets need to be collected using python manage.py download_vendor_files .","title":"VENDOR_CDN"},{"location":"settings/#daiquiriarchivesettings","text":"","title":"daiquiri.archive.settings"},{"location":"settings/#archive_base_path","text":"Default: os.path.join(BASE_DIR, 'files') Sets the absolute base path of the files served by the archive module in the local file system.","title":"ARCHIVE_BASE_PATH"},{"location":"settings/#archive_download_dir","text":"Default: os.path.join(BASE_DIR, 'download') Sets the absolute path where the zip files for downloads from the archive are located in the local file system.","title":"ARCHIVE_DOWNLOAD_DIR"},{"location":"settings/#archive_anonymous","text":"Default: False Designates if the archive interface can be accessed by anonymus users.","title":"ARCHIVE_ANONYMOUS"},{"location":"settings/#archive_schema","text":"Default: 'daiquiri_archive' Sets the schema for the archive in the data database.","title":"ARCHIVE_SCHEMA"},{"location":"settings/#archive_table","text":"Default: 'files' Sets the table for the archive in the schema set by ARCHIVE_SCHEMA the data database.","title":"ARCHIVE_TABLE"},{"location":"settings/#archive_columns","text":"Default: [ { 'name': 'id', 'hidden': True }, { 'name': 'timestamp', 'label': 'Timestamp' }, { 'name': 'file', 'label': 'Filename', 'ucd': 'meta.file' }, { 'name': 'collection', 'hidden': True }, { 'name': 'path', 'hidden': True } ] Sets the additional columns for the archive in the table set by ARCHIVE_TABLE the data database.","title":"ARCHIVE_COLUMNS"},{"location":"settings/#daiquiriauthsettings","text":"","title":"daiquiri.auth.settings"},{"location":"settings/#auth_signup","text":"Default: False Designates if users can register for an account. If set to false, all users need to be created through the Django admin system.","title":"AUTH_SIGNUP"},{"location":"settings/#auth_workflow","text":"Default: None Sets the workflow for user registration. Options are None : Newly registered users can log in after registartion. 'activation' : Newly registered users need to be activated by a manager or admin. 'confirmation' : Newly registered users need to be confirmed by a manager before they are activated by an admin.","title":"AUTH_WORKFLOW"},{"location":"settings/#auth_detail_keys","text":"Default: [] Sets additional details to be asked from the users when registering. An example would be: AUTH_DETAIL_KEYS = [ { 'key': 'affiliation', 'label': 'Affiliation', 'data_type': 'text', 'required': True, 'options': [] }, ] where: key is the internal identifier, label the text shown in the interface, datatype the type of the detail which affects the widget to be used ( 'text' , 'textarea' , 'select' , 'radio' , 'multiselect' , or 'checkbox' ), required whether this detail is required or not, and options a list of options for select, radio or checkboxes widgets of the form [{'id': id, 'label': label}, ...] .","title":"AUTH_DETAIL_KEYS"},{"location":"settings/#auth_terms_of_use","text":"Default: False Designates whether terms of use are displayed on the signup page and need to be accepted to register. The text of to displayed needs to be configured in a template account/terms_of_use.html .","title":"AUTH_TERMS_OF_USE"},{"location":"settings/#daiquiriconesearchsettings","text":"","title":"daiquiri.conesearch.settings"},{"location":"settings/#conesearch_adapter","text":"Default: 'daiquiri.conesearch.adapter.SimpleConeSearchAdapter' Sets the adapter class to be used by the cone search api. The adapter class encapsulated all operations creating a cone search votable output from the api request. Custom adapter need to enherit from daiquiri.conesearch.adapter.BaseConeSearchAdapter .","title":"CONESEARCH_ADAPTER"},{"location":"settings/#conesearch_anonymous","text":"Default: False Designates if cone searches can be done by by anonymous users.","title":"CONESEARCH_ANONYMOUS"},{"location":"settings/#daiquiricontactsettings","text":"","title":"daiquiri.contact.settings"},{"location":"settings/#announcement_message_filter","text":"Default: daiquiri.contact.filters.DefaultMessageFilter Sets the filter class to be used by the announcement messages. The filter class encapsulates all filter methods used to show announcements to a filtered set of users. Custom filter class must enherit from daiquiri.contact.filters.DefaultMessageFilter . All custom filter methods are required to have a single parameter request . The announcement messages can be added in the Django admin site. In order to show the messages on a webpage, one has to load the announcement tags in the template {% load announcement_tags %} and then place {% show_announcements %} where the messages should be shown.","title":"ANNOUNCEMENT_MESSAGE_FILTER"},{"location":"settings/#daiquiricutoutsettings","text":"","title":"daiquiri.cutout.settings"},{"location":"settings/#cutout_adapter","text":"Default: 'daiquiri.cutout.adapter.SimpleCutOutAdapter' Sets the adapter class to be used by the cutout api. The adapter class encapsulated all operations creating a cut out from the api request. Custom adapter need to enherit from daiquiri.cutout.adapter.BaseCutOutAdapter .","title":"CUTOUT_ADAPTER"},{"location":"settings/#cutout_anonymous","text":"Default: False Designates if the cutout interface can be accessed by anonymus users.","title":"CUTOUT_ANONYMOUS"},{"location":"settings/#daiquirifilessettings","text":"","title":"daiquiri.files.settings"},{"location":"settings/#files_base_path","text":"Default: os.path.join(BASE_DIR, 'files') Sets the absolute base path of the files served by the files module in the local file system. Should be set in .env .","title":"FILES_BASE_PATH"},{"location":"settings/#files_base_url","text":"Default: None Sets the absolute URL for this Daiquiri app to be prepended to file references when downloading query results. This is done for columns with the meta.ref;meta.file , meta.ref;meta.image or meta.ref;meta.note UCD. Should be set in .env .","title":"FILES_BASE_URL"},{"location":"settings/#files_docs_rel_path","text":"Default: None Sets the relative file path to the documentation files on which the file search will be executed. The path is given relative to the FILES_BASE_PATH . In order to use the search function for the files, one has to include the search field into the template. {% include 'files/search-input.html' %} The layout of the results page can be changed by overloading the template files/search-results.html in the daiquri app.","title":"FILES_DOCS_REL_PATH"},{"location":"settings/#files_search_results_per_page","text":"Default: 5 Sets the number of search results per page.","title":"FILES_SEARCH_RESULTS_PER_PAGE"},{"location":"settings/#daiquirimeetingssettings","text":"","title":"daiquiri.meetings.settings"},{"location":"settings/#meetings_contribution_types","text":"Default: [ ('talk', _('Talk')), ('poster', _('Poster')) ] Sets the types of contributions to be selected by partcipants when registering.","title":"MEETINGS_CONTRIBUTION_TYPES"},{"location":"settings/#meetings_payment_choices","text":"Default: [ ('cash', _('cash')), ('wire', _('wire transfer')), ] Sets the different payment choices to be selected by partcipants when registering.","title":"MEETINGS_PAYMENT_CHOICES"},{"location":"settings/#meetings_participant_detail_keys","text":"Default: [] Sets additional details to be asked from the participants when registering. An example would be: MEETINGS_PARTICIPANT_DETAIL_KEYS = [ { 'key': 'affiliation', 'label': 'Affiliation', 'data_type': 'text', 'required': True }, { 'key': 'dinner', 'label': 'Conference dinner', 'data_type': 'radio', 'required': True, 'options': [ {'id': 'yes', 'label': 'yes'}, {'id': 'no', 'label': 'no'} ] } ] where: key is the internal identifier, label the text shown in the interface, datatype the type of the detail which affects the widget to be used ( 'text' , 'textarea' , 'select' , 'radio' , 'multiselect' , or 'checkbox' ), required whether this detail is required or not, and options a list of options for select, radio or checkboxes widgets of the form [{'id': id, 'label': label}, ...] .","title":"MEETINGS_PARTICIPANT_DETAIL_KEYS"},{"location":"settings/#meetings_abstract_max_length","text":"Default: 2000 Sets the maximum lenght of an abstract.","title":"MEETINGS_ABSTRACT_MAX_LENGTH"},{"location":"settings/#daiquirimetadatasettings","text":"","title":"daiquiri.metadata.settings"},{"location":"settings/#metadata_column_permissions","text":"Default: False Designates if permissions can be assigned to individual columns (in addition to tables and schemas). This is an experimental feature.","title":"METADATA_COLUMN_PERMISSIONS"},{"location":"settings/#metadata_base_url","text":"Default: None Sets the absolute URL of the metadata module, e.g. http://example.com/metadata/. The URL is used to create links to the landing pages for schemas and tables in VOTables if a DOI is not set.","title":"METADATA_BASE_URL"},{"location":"settings/#daiquirioaisettings","text":"","title":"daiquiri.oai.settings"},{"location":"settings/#oai_schema","text":"Default: OAI_SCHEMA Sets the name of the schema for OAI records. If more than one Daiquiri application is using the same data database, they cannot use the same OAI_SCHEMA schema. This setting must be set in .env","title":"OAI_SCHEMA"},{"location":"settings/#oai_adapter","text":"Default: 'daiquiri.metadata.adapter.RegistryDoiMetadataOaiAdapter' Sets the adapter class to be used by the OAI-PMH api. The adapter class encapsulated all operations to set up and retrieve the OAI records. Custom adapter need to enherit from daiquiri.metadata.adapter.BaseOaiAdapter . Usually this will be done in the Daiquiri app, e.g. OAI_ADAPTER = 'app.adapter.OaiAdapter'","title":"OAI_ADAPTER"},{"location":"settings/#oai_page_size","text":"Default: 500 Number of records returned in a OAI-PMH request.","title":"OAI_PAGE_SIZE"},{"location":"settings/#daiquiriquerysettings","text":"","title":"daiquiri.query.settings"},{"location":"settings/#query_anonymous","text":"Default: False Designates if the query interface can be accessed by anonymus users. The permissions on schemas and tables need to be configured using the metadata interface.","title":"QUERY_ANONYMOUS"},{"location":"settings/#query_user_schema_prefix","text":"Default: 'daiquiri_user_' Sets the prefix for user schemas in the data database. Each user has a private schema where the result table of successful queries are stored.","title":"QUERY_USER_SCHEMA_PREFIX"},{"location":"settings/#query_quota","text":"Default: { 'anonymous': '100Mb', 'user': '10000Mb', 'users': {}, 'groups': {} } Sets the maximum quota for tables in a user\u2019s personal schema. The quota need to be set for the anonymous user as well as regular loggen in users ( user ). Additionally, users or groups can be asigned individual quotas, e.g.: { 'anonymous': '100Mb', 'user': '10000Mb', 'users': { 'admin': '1000Gb' }, 'groups': { 'collab': '100Gb' } } If more than one quota applies, the maximum is used.","title":"QUERY_QUOTA"},{"location":"settings/#query_sync_timeout","text":"Default: 5 Sets the timeout for syncronous (TAP) queries in seconds.","title":"QUERY_SYNC_TIMEOUT"},{"location":"settings/#query_max_active_jobs","text":"Default: { 'anonymous': '1' } Sets the maximum of simultanous jobs for users. The setting work analog to \u2018QUERY_QUOTA\u2019. If more than one maximum applies, the maximum is used. If no maximum is given, like the default setting for logged users, no maximum is enforced.","title":"QUERY_MAX_ACTIVE_JOBS"},{"location":"settings/#query_queues","text":"Default: [ { 'key': 'default', 'label': 'Default', 'timeout': 10, 'priority': 1, 'access_level': 'PUBLIC', 'groups': [] } ] Set the different queue, which can be selected by the users. Each queue is represented by a dictionary where: key is the internal identifier, label is the text shown in the interface, timeout the maximum excecution time in seconds, priority is a integer number indicationg the priority in which jobs are executed, and access_level and groups the usual restiction on who can use this queue. Jobs in a queue with higher priority are selected first when a query worker becomes available.","title":"QUERY_QUEUES"},{"location":"settings/#query_languages","text":"Default: [ { 'key': 'adql', 'version': 2.0, 'label': 'ADQL', 'description': '', 'quote_char': '\"' } ] Sets the different query languages, which can be selected by the users. Each query language is represented by a dictionary where: key is the internal identifier, label is the text shown in the interface, description is additional information shown, e.g. in TopCat, and quote_char the character used by the database system to quote identifiers. Already implemented in Daiquiri are adql , postgresql , and mysql . Apart from ADQL, the query language must match the database system of the data database.","title":"QUERY_LANGUAGES"},{"location":"settings/#query_forms","text":"Default: [ { 'key': 'sql', 'label': 'SQL query', 'service': 'query/js/forms/sql.js', 'template': 'query/query_form_sql.html' } ] Sets the form available for the users in the query interface. Each form is represented by a dictionary where: key is the internal identifier, label is the text shown in the interface, service the path AngularJS service containing the client side logic, and template the path to the Django template with the markup for the form. Included in Daiquiri are sql and (simplyfied) cone and box services.","title":"QUERY_FORMS"},{"location":"settings/#query_plots","text":"Default: [ { 'key': 'scatter_plot', 'label': 'Scatter', 'is_active': True, }, { 'key': 'scatter_cmap_plot', 'label': 'Scatter (color coded)', 'is_active': True, }, { 'key': 'histogram', 'label': 'Histogram', 'is_active': True, } ] Sets the visibility of the available plot types in the web interface. key is the internal identifier, label is the type name shown in the interface, and is_active controls whether the plot type is used in the interface.","title":"QUERY_PLOTS"},{"location":"settings/#query_dropdowns","text":"Default: [ { 'key': 'simbad', 'service': 'query/js/dropdowns/simbad.js', 'template': 'query/query_dropdown_simbad.html', 'options': { 'url': 'http://simbad.u-strasbg.fr/simbad/sim-id' } }, { 'key': 'vizier', 'service': 'query/js/dropdowns/vizier.js', 'template': 'query/query_dropdown_vizier.html', 'options': { 'url': 'http://vizier.u-strasbg.fr/viz-bin/votable', 'catalogs': ['I/322A', 'I/259'] } } ] Sets the additional drop down menus above the SQL query interface available for the users. Each drop down is represented by a dictionary where: key is the internal identifier, service the path AngularJS service containing the client side logic, template the path to the Django template with the markup, and options additional options specific to the drop down. Included in Daiquiri are simbad and vizier services.","title":"QUERY_DROPDOWNS"},{"location":"settings/#query_download_dir","text":"Default: os.path.join(BASE_DIR, 'download') Sets the absolute base path of the download files served by the query module in the local file system.","title":"QUERY_DOWNLOAD_DIR"},{"location":"settings/#query_default_download_format","text":"Default: 'votable' Sets the default download format.","title":"QUERY_DEFAULT_DOWNLOAD_FORMAT"},{"location":"settings/#query_download_formats","text":"Default: [ { 'key': 'votable', 'extension': 'xml', 'content_type': 'application/xml', 'label': 'IVOA VOTable XML file - TABLEDATA serialization', 'help': 'A XML file using the IVOA VOTable format. Use this option if you intend to use VO compatible software to further process the data.' }, { 'key': 'csv', 'extension': 'csv', 'content_type': 'text/csv', 'label': 'Comma separated Values', 'help': 'A text file with a line for each row of the table. The fields are delimited by a comma and quoted by double quotes. Use this option for a later import into a spreadsheed application or a custom script. Use this option if you are unsure what to use.' }, { 'key': 'fits', 'extension': 'fits', 'content_type': 'application/fits', 'label': 'FITS', 'help': 'Flexible Image Transport System (FITS) file format.' }, { 'key': 'parquet', 'extension': 'parquet', 'content_type': 'application/parquet', 'label': 'Parquet', 'help': 'Apache Parquet file format.', }, ] Sets the available default download formats. Each format is represented by a dictionary where: key is the internal identifier, extension the file extension, content_type the content type, label the text shown in the interface, and help a more verbose help text for the format. NOTE : If you want faster parquet file generation, get the lastest binary of pg2parquet and put it somewhere covered by your PATH variable. This rust-binary is up to 4 times faster as the Python-based fastparquet solution that works as a fallback.","title":"QUERY_DOWNLOAD_FORMATS"},{"location":"settings/#query_upload","text":"Default: True Enables the upload functionality in the query interface. QUERY_UPLOAD_LIMIT Default: { 'anonymous': '10Mb', 'user': '100Mb', 'users': {}, 'groups': {} } Sets the maximum quota for uploads by a user. The quota need to be set for the anonymous user as well as regular loggen in users ( user ). Additionally, users or groups can be asigned individual quotas, much like with QUERY_QUOTA .","title":"QUERY_UPLOAD"},{"location":"settings/#daiquiriservesettings","text":"","title":"daiquiri.serve.settings"},{"location":"settings/#serve_download_dir","text":"Default: os.path.join(BASE_DIR, 'download') Sets the absolute base path of the download files served by the serve module in the local file system.","title":"SERVE_DOWNLOAD_DIR"},{"location":"settings/#serve_resolver","text":"Default: None Sets the a resolver class to handle references in tables served by the serve module.","title":"SERVE_RESOLVER"},{"location":"settings/#daiquiristatssettings","text":"","title":"daiquiri.stats.settings"},{"location":"settings/#stats_resource_types","text":"Default: [ { 'key': 'ARCHIVE_DOWNLOAD', 'label': 'Archive downloads' }, { 'key': 'CONESEARCH', 'label': 'Performed cone searches' }, { 'key': 'CUTOUT', 'label': 'Performed cutouts' }, { 'key': 'FILE', 'label': 'File downloads' }, { 'key': 'QUERY', 'label': 'Queries' } ] Sets the aggegated stats shown in the stats management overview.","title":"STATS_RESOURCE_TYPES"},{"location":"settings/#daiquiritapsettings","text":"","title":"daiquiri.tap.settings"},{"location":"settings/#tap_schema","text":"Default: 'TAP_SCHEMA' Sets the name of the TAP schema. If more than one Daiquiri application is using the same data database, they cannot use the same TAP schema. Therefore the schema name TAP_SCHEMA is replaced before queries are submitted. This setting must be set in .env","title":"TAP_SCHEMA"},{"location":"settings/#tap_upload","text":"Default: 'TAP_UPLOAD' Sets the name of the schema for TAP uploads. If more than one Daiquiri application is using the same data database, they cannot use the same TAP_UPLOAD schema. Therefore the schema name TAP_UPLOAD is replaced before queries are submitted. This setting must be set in .env","title":"TAP_UPLOAD"},{"location":"settings/#daiquiriuwssettings","text":"","title":"daiquiri.uws.settings"},{"location":"settings/#uws_resources","text":"Default: [] Configures UWS services (in addition to the TAP module). E.g.: { 'prefix': r'query', 'viewset': 'daiquiri.query.viewsets.UWSQueryJobViewSet', 'base_name': 'uws_query' } where: prefix is part of the base URL of the service (e.g. http://example.com/usw/query), viewset is the ViewSet class handling the requests (neets to enherit from daiquiri.jobs.viewsets.AsyncJobViewSet ), and base_name a basename needed for the integration in the Django REST framework.","title":"UWS_RESOURCES"},{"location":"settings/#daiquiriwordpresssettings","text":"","title":"daiquiri.wordpress.settings"},{"location":"settings/#wordpress_path","text":"Default: '/opt/wordpress' Sets the location of the WordPress installation on the local file system.","title":"WORDPRESS_PATH"},{"location":"settings/#wordpress_ssh","text":"Default: None Sets the destination for a SSH connection to use with wp-cli . Use this setting if WordPress is not installed on the same host as Daiquiri. The local wp-cli will then connect to the remote system using ssh. An example would be: WORDPRESS_SSH=example.com:/opt/daiquiri This option overided WORDPRESS_PATH .","title":"WORDPRESS_SSH"},{"location":"settings/#wordpress_cli","text":"Default: '/opt/wp-cli/wp' Sets the location of the wp-cli script on the local file system.","title":"WORDPRESS_CLI"},{"location":"settings/#wordpress_url","text":"Default: '/cms/' Sets the base url of the WordPress instance.","title":"WORDPRESS_URL"}]}